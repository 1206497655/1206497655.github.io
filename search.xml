<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>探索发现--关于compositionstart、input和compositionend事件去除拼音响应的研究</title>
      <link href="/2018/11/28/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0-%E5%85%B3%E4%BA%8Ecompositionstart%E3%80%81input%E5%92%8Ccompositionend%E4%BA%8B%E4%BB%B6%E5%8E%BB%E9%99%A4%E6%8B%BC%E9%9F%B3%E5%93%8D%E5%BA%94%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/11/28/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0-%E5%85%B3%E4%BA%8Ecompositionstart%E3%80%81input%E5%92%8Ccompositionend%E4%BA%8B%E4%BB%B6%E5%8E%BB%E9%99%A4%E6%8B%BC%E9%9F%B3%E5%93%8D%E5%BA%94%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>关于利用compositionstart、input和compositionend事件给input元素即时响应去除拼音阶段响应的发现：compositionstart事件在拼音输入阶段开始触发的事件，compositionend事件在输入拼音阶段结束后触发的事件，大部分浏览器都相同，而input事件在不同的浏览器或不同的版本的浏览器之间的顺序有所不同，部分是发生在compositionend事件之前，部分却是在compositionend事件之后，这样给input元素针对中文做即时响应时带来许多不良影响，针对此种情况可以使用keyup事件替代，因为大部分浏览器keyup事件都是在compositionend事件之后的。<a id="more"></a></p><p>测试代码大概是：</p><pre><code>var inputZh = false  &#x2F;&#x2F; 是否结束输入法获取文字标记inputNode.addEventListener(&#39;compositionstart&#39;, function () {    inputZh = false &#x2F;&#x2F; 开始输入法时置为 false    console.log(&#39;compositionstart&#39;)})oinputNode.addEventListener(&#39;compositionend&#39;, function () {    inputZh = true &#x2F;&#x2F; 结束输入法时置为true    console.log(&#39;compositionend&#39;)})inputNode.addEventListener(&#39;inputNode&#39;, function() {    console.log(&#39;input&#39;)    if (inputZh) { &#x2F;&#x2F; 按下空格键结束输入法时进行响应        &#x2F;* 要处理的代码块 *&#x2F;    }})</code></pre><p>下图是chrome 33拼音输入控制台打印结果：<br><img src="/img/11/28/chrome 33.0.1750.117.png" alt=""><br><!-- ![](E:\notes\img\chrome 33.0.1750.117.png) --></p><p>分析：chrome 33运行此段代码时，拼音输入法在按下空格键之后（即结束输入法获得文字）触发的事件顺序为: compositionend -&gt; input， 这样子就能在compositionend事件时把inputZh置为true然后再之后触发的input事件中处理响应任务。</p><p>下图时chrome 70 拼音输入控制台打印结果：</p><p><img src="/img/11/28/chrome 70.0.3538.102.png" alt=""><br><!-- ![](E:\notes\img\chrome 70.0.3538.102.png) --></p><p>分析：chrome 70的结果显然不是我们想要的。拼音输入把结束输入法的空格键也计算在输入拼音阶段，导致无法在input事件前通过compositionend事件使inputZh标志置为true，所以无法实现拼音过滤。</p><p>下图时firfox 59 拼音输入控制台打印结果：</p><p><img src="/img/11/28/fireFox 63.03.png" alt=""><br><!-- ![ ](E:\notes\img\fireFox 63.03.png) --></p><p>firefox 59与chrome 33相同。</p><p>虽然只是简单的测试了一下，但是从两大浏览器就可以得出input事件与compositionstart、compositionend顺序不一致的问题。解决这个问题的最简单的方法就是使用keyup事件替代input事件，因为大多数浏览器的keyup顺序都是一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> compositionstart </tag>
            
            <tag> compositionend </tag>
            
            <tag> input </tag>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决高度设置为auto时无法过渡的情况</title>
      <link href="/2018/11/28/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E4%B8%BAauto%E6%97%B6%E6%97%A0%E6%B3%95%E8%BF%87%E6%B8%A1%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2018/11/28/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E4%B8%BAauto%E6%97%B6%E6%97%A0%E6%B3%95%E8%BF%87%E6%B8%A1%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>css高度过渡(从0过渡至过渡为auto情况),transition过渡只能从一个明确的属性值过渡至另一个明确的属性值,不能从任意一个不确定值过渡至一个确定值,这样是不起作用的,例如常见的<strong>height: 0</strong>过渡至<strong>height: auto</strong>.解决办法:<br><a id="more"></a><br>    使用transform：scaleY(0)替代始值。transform: scaleY(1)替代终值。<br><pre><code>css: {  transform：scaleY(0);  transform-origin: 0% 0%;}css: {  transform: scaleY(1)}</code></pre></p><p> 注意: 未添加transform-origin: 0% 0%;的情况下默认从过度对象Y轴中点开始往上下扩张，使用后默认从Y轴顶点开始向下扩张。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 高度过渡 </tag>
            
            <tag> transition </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设置VSCode下Vue代码自动格式化</title>
      <link href="/2018/11/28/%E8%AE%BE%E7%BD%AEVSCode%E4%B8%8BVue%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2018/11/28/%E8%AE%BE%E7%BD%AEVSCode%E4%B8%8BVue%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>安装Vetur插件，打开VSCode下的setting.json，加入如下配置:<br><a id="more"></a><br><pre><code>&#x2F;&#x2F; 保存自动格式化&quot;editor.formatOnSave&quot;: true,&#x2F;&#x2F; 保存时自动fix&quot;eslint.autoFixOnSave&quot;: true,&#x2F;&#x2F; 添加 vue 支持&quot;eslint.validate&quot;: [    &quot;javascript&quot;,    &quot;javascriptreact&quot;,    {        &quot;language&quot;: &quot;vue&quot;,        &quot;autoFix&quot;: true    }],&#x2F;&#x2F; 屏蔽vetur的js格式化&quot;vetur.format.defaultFormatter.js&quot;: &quot;none&quot;&#x2F;&#x2F; 使用插件格式化 html&quot;vetur.format.defaultFormatter.html&quot;: &quot;prettyhtml&quot;</code></pre></p><p>注意：<br>    1.代码风格使用著名的prettier风格。<br>    2.在*.vue文件保存时会执行两次格式化，一次是Vetur插件的，另一次是ESlint的，应该去掉其中一个以节省性能和时间。一般选择去掉Vetur的，因为ESlint格式化出阿来的JS才符合ESlint的规则，不容易报红。所以加入 “vetur.format.defaultFormatter.js”: “none”以屏蔽Vetur的JS格式化。<br>    3.ESlint不会格式化Vue文件中的模板部分，但是会监测….所以设置Vetur的HTML格式化风格时应尽量选择与ESlint的更友好的Prettier风格，即以上选项。<br>    4.Vetur下的css和其它css预处理语言默认使用Prettier风格，所以这里不用自行配置。</p><p>完成以上配置后，就能愉快的写代码了~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> vue </tag>
            
            <tag> 自动格式化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git的日常工作流程总结</title>
      <link href="/2018/11/28/git%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/28/git%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了一下在团队开发种自己日常使用的一下git操作以及流程：<br><a id="more"></a><br><pre><code>&#x2F;&#x2F; 去自己的工作分支$ git checkout work&#x2F;&#x2F; 工作&#x2F;&#x2F; ....&#x2F;&#x2F; 提交工作分支的修改$ git commit -a&#x2F;&#x2F; 回到主分支$ git checkout master&#x2F;&#x2F; 获取远程最新的修改，此时不会产生冲突$ git pull&#x2F;&#x2F; 回到工作分支$ git checkout work&#x2F;&#x2F; 用rebase合并主干的修改，如果有冲突在此时解决$ git merge master&#x2F;&#x2F; 回到主分支$ git checkout master&#x2F;&#x2F; 合并工作分支的修改，此时不会产生冲突。$ git merge work&#x2F;&#x2F; 提交到远程主干$ git push</code></pre></p><p>这样做的好处是，远程主干上的历史永远是线性的。每个人在本地分支（本地master和本地work）解决冲突，不会在主干上产生冲突。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 常用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--模板TemplatedMixin</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BFTemplatedMixin/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BFTemplatedMixin/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;_TemplatedMixin(params,srcNodeRef) 用于模板实例化的部件的混合<a id="more"></a><br>&emsp;&emsp;on方法不需要前缀。包括三个参数。<br>@param: params<br>&emsp;&emsp;类型：Object | null<br>&emsp;&emsp;&emsp;&emsp;描述：部件的初始化参数哈希值，包括标量值（如标题，持续时间等）和函数，通常是onClick之类的回调。<br>&emsp;&emsp;&emsp;&emsp;哈希可以包含任何窗口小部件的属性，不包括只读属性。<br>@param: srcNodeRef<br>&emsp;&emsp;类型：DOMNode | String<br>&emsp;&emsp;描述：可选的。如果指定了srcNodeRef（DOM节点），则将srcNodeRef替换为方法生成的DOM树。<br><pre><code>require([            &#39;dojo&#x2F;dom&#39;,            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &quot;dijit&#x2F;_WidgetBase&quot;,            &#39;dijit&#x2F;_TemplatedMixin&#39;,            &#39;dojo&#x2F;domReady!&#39;        ], function (dom, declare, _WidgetBase, _TemplatedMixin) {            &#x2F;&#x2F; 用法            var foo = new _TemplatedMixin(params, srcNodeRef);            &#x2F;&#x2F; 属性            &#x2F;&#x2F; attachScope：附加点和事件将作用于的对象。 默认为&#39;this&#39;。            &#x2F;&#x2F; searchContainerNode            &#x2F;&#x2F; templatePath: 相对于dojo.baseUrl的此部件的模板（HTML文件）的路径。 不推荐：使用带有require（[...“dojo &#x2F; text！...”]，...）的templateString代替            &#x2F;&#x2F; templateString: 表示窗部件html模板的字符串。 与dojo.cache()结合使用以从文件加载。            &#x2F;&#x2F; 方法            &#x2F;**             *  buildRendering() 解析HTML模板，从模板构造此部件的UI，设置this.domNode。             *&#x2F;            &#x2F;**             *  destroyRendering() 销毁部件的DOM。             *&#x2F;            &#x2F;**             * getCachedTemplate(templateString,alwaysUseString,doc) 根据templatePath或templateString键获取模板的静态方法             * @param: templateString             *         类型：String             *         描述：模板             * @param: alwaysUseString             *         类型：Boolean             *         描述：不要为此模板缓存DOM树，即使它没有任何变量             * @param: doc             *         类型：Document             *         描述：可选的。目标文件。 如果未指定，则默认为全局文档。             *&#x2F;            &#x2F;**             * 大部分的dijit部件都混入了dijit&#x2F;_TemplatedMixin。它需要一个HTML模板，并根据该模板创建小部件的DOM树。             * 换言之，它为你实现了buildRendering()这个方法。请注意，名称中的下划线表示_TemplatedMixin不是私有类，             * 而是它是一个mixin，而不是一个小部件。             *&#x2F;            &#x2F;&#x2F; 用法            &#x2F;&#x2F; 声明部件时混入dijit &#x2F; _TemplatedMixin，然后定义一个templateString。            declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                templateString: &quot;&lt;div&gt;hello world&lt;&#x2F;div&gt;&quot;            });            &#x2F;&#x2F; 模板            &#x2F;&#x2F; 模板在widget属性templateString中指定，并指向具有单个根节点的，在标签上具有特殊属性，可能还有替换变量的            &#x2F;&#x2F; 某个HTML。            &#x2F;&#x2F; 它可以指定为字符串：            declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                templateString: &quot;&lt;div&gt;hello world&lt;&#x2F;div&gt;&quot;            });            &#x2F;&#x2F; 或使用dojo&#x2F;text!从文件中提取插入：            require([                &quot;dojo&#x2F;declare&quot;,                &quot;dijit&#x2F;_WidgetBase&quot;,                &quot;dijit&#x2F;_TemplatedMixin&quot;,                &quot;dojo&#x2F;text!myNameSpace&#x2F;templates&#x2F;MyWidget.html&quot;            ], function (declare, _WidgetBase, _TemplatedMixin, template) {                declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                    templateString: template,                });            });            &#x2F;&#x2F; 构建或发布的Dijit树时，调用字符串将internStrings转换为dojo&#x2F;text！，避免在用户加载部件时网络请求。            &#x2F;**             * 除了像class这样的典型属性外，模板中的标签还可以具有这些特殊属性：             * 1.data-dojo-attach-point             * 2.data-dojo-attach-event             *              * data-dojo-attach-point             * 在widget的JavaScript中，你可能希望直接引用具有某些html模板的dom节点，在这种情况下，widget将需要             * 使用统计访问&lt;span&gt;以更改值。             * 你可能认为窗口小部件作者可以在html模板中使用id属性，然后在部件的js中使用dojo.byId()。 但如果             * 这样做，在创建了两个或更多个部件实例时，它们都将具有相同的id, 很显然代码会出错。             * 相反，你的部件需要执行以下操作：             *      1.在部件模板的html中，对于这些变量应该对应的每个节点，需要添加属性：data-dojo-attach-point =&quot;yourVariableNameHere&quot;。             *      2.在部件的js代码中使用这些节点的变量(未声明)。在这种情况下将会访问this.counter。             * 变量未声明的原因是，当_TemplatedMixin中的代码在上面的步骤1中扫描html，并且它在data-dojo-attach-point             * 属性中找到变量时，它会动态地将这些变量添加到窗口小部件类中。             *              * data-dojo-attach-event             * data-dojo-attach-event将自动从DOM节点上的事件建立连接（在本例中为onclick），以调用窗口小部件中的方法（在本例中为increment（））。             * 以下是data-dojo-attach-point和data-dojo-attach-event的示例：             **&#x2F;            require([                &quot;dojo&#x2F;declare&quot;, &quot;dojo&#x2F;parser&quot;,                &quot;dijit&#x2F;_WidgetBase&quot;, &quot;dijit&#x2F;_TemplatedMixin&quot;, &quot;dojo&#x2F;domReady!&quot;            ], function (declare, parser, _WidgetBase, _TemplatedMixin) {                parser.parse();                return declare(&quot;FancyCounter&quot;, [dijit._WidgetBase, dijit._TemplatedMixin], {                    &#x2F;&#x2F; counter                    _i: 0,                    templateString:                        &quot;&lt;div&gt;&quot; +                        &quot;&lt;button data-dojo-attach-event=&#39;onclick: increment&#39;&gt;press me&lt;&#x2F;button&gt;&quot; +                        &quot;&amp;nbsp; count: &lt;span data-dojo-attach-point=&#39;counter&#39;&gt;0&lt;&#x2F;span&gt;&quot; +                        &quot;&lt;&#x2F;div&gt;&quot;,                    increment: function (evt) {                        this.counter.innerHTML = ++this._i;                    }                });                &#x2F;**                 * containerNode                 * 通常在标记中声明的部件将包含一些其他DOM。例如                 * &lt;button data-dojo-type=&quot;dijit&#x2F;form&#x2F;Button&quot;&gt;press me&lt;&#x2F;button&gt;                 *                  * 如果模板定义了data-dojo-attach-point =&quot;containerNode&quot;，则srcNodeRef中的子节点将被复制到此节点。                 * 例如                 **&#x2F;                require([                    &quot;dojo&#x2F;declare&quot;, &quot;dojo&#x2F;parser&quot;,                    &quot;dijit&#x2F;_WidgetBase&quot;, &quot;dijit&#x2F;_TemplatedMixin&quot;, &quot;dojo&#x2F;domReady!&quot;                ], function (declare, parser, _WidgetBase, _TemplatedMixin) {                    parser.parse();                    return declare(&quot;MyButton&quot;, [dijit._WidgetBase, dijit._TemplatedMixin], {                        templateString:                            &quot;&lt;button data-dojo-attach-point=&#39;containerNode&#39; data-dojo-attach-event=&#39;onclick: onClick&#39;&gt;&lt;&#x2F;button&gt;&quot;,                        onClick: function (evt) {                            alert(&quot;Awesome!!&quot;);                        }                    });                });                &#x2F;&#x2F; Substitution variables(替代变量)                &#x2F;&#x2F; 模板也可以引用替换变量，如$ {title}。 $ {title}引用窗口小部件的title属性。                &#x2F;&#x2F; 但是，不推荐这样做，因为它只处理小部件实例化的标题设置。换言之，如果使用替换变量，                &#x2F;&#x2F; myWidget.set（&#39;title&#39;，&#39;myNewTitle&#39;）将不起作用。                &#x2F;&#x2F; 常见的陷阱                &#x2F;&#x2F; 1.确保模板中只有一个根节点                &#x2F;&#x2F; 2.不要使用注释启动模板（或结束它）（因为这在技术上意味着有两个节点）                &#x2F;&#x2F; 3.避免在模板末尾使用&lt;&#x2F; div&gt;            });        })</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> dojoJs </tag>
            
            <tag> _TemplatedMixin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决VSCode触摸板卡顿问题</title>
      <link href="/2018/07/29/%E8%A7%A3%E5%86%B3VSCode%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/29/%E8%A7%A3%E5%86%B3VSCode%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Setting.json中增加选项：<br><pre><code>&quot;window.smoothScrollingWorkaround&quot;: true,&quot;window.titleBarStyle&quot;: &quot;native&quot;</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> 卡顿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--创建widget</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BAwidget/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BAwidget/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dijit / _WidgetBase是Dijit包中所有组件的基类，也是Dojo中所有组件的一个基类。通常一个组件也会继承一些属性融合的工具类，例如：dijit._TemplatedMixin。 注意：_WidgetBase名字中的下划线表示它是一个基类，不可直接使用，而不是表示它是一个私有的类。<a id="more"></a>_WidgetBase是一个不可以直接使用的基类，需要继承。一般在创建dojo自定义组件时，继承来自_WidgetBase基类的属性和方法，它的作用是赋予自定义组件一些常用些属性，给你的组件创建生命周期以及提供一些操作组件的API。<br><pre><code>require([            &quot;dojo&quot;,            &#39;dojo&#x2F;dom&#39;,            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &#39;dijit&#x2F;_WidgetBase&#39;,            &#39;dijit&#x2F;form&#x2F;TextBox&#39;,            &#39;dijit&#x2F;form&#x2F;Button&#39;,            &#39;demo&#x2F;test&#39;,            &#39;dijit&#x2F;Dialog&#39;,            &#39;dojo&#x2F;on&#39;,            &#39;dojo&#x2F;domReady!&#39;        ], function (dojo, dom, declare, WidgetBase, TextBox, Button, test, Dialog, on) {            &#x2F;&#x2F; 用法            &#x2F;&#x2F; Dojo中所有的组件通过调用dojo.declare()继承_WidgetBase，然后根据组件的生命周期定义大量的方法。            declare(&quot;MyWidget&quot;, WidgetBase, {                &#x2F;&#x2F;do something            });            &#x2F;&#x2F; 部分属性            &#x2F;&#x2F; id: 标识微件的String类型的唯一值            &#x2F;&#x2F; lang: 很少使用的String值，可以重写Dojo默认的locale            &#x2F;&#x2F; dir: 用于双向支持            &#x2F;&#x2F; class: 部件domNode的html样式            &#x2F;&#x2F; style: 部件domNode的style属性            &#x2F;&#x2F; title: 一般表示原生提示的html title属性            &#x2F;&#x2F; baseClass：部件的根CSS样式            &#x2F;&#x2F; srcNodeRef: 部件在部件化之前的原始Dom 节点，如果有的话。注意这个属性与部件的类型有关(如基于模板的微件)，并且在postCreate之后可能会被丢弃。            &#x2F;&#x2F; tooltip：widget 根节点上的 class, 用来创建指示 widget 状态(State)的 css classes            &#x2F;&#x2F; 部分方法            &#x2F;**            * defer(fcn,delay) 包装到setTimeout以避免在销毁原始窗口小部件后执行delay函数。 使用remove方法返回一个对象句柄。            * @param: fcn            *         类型: Function            *         描述：   参考函数。            * @param：delay            *         类型：Number            *         描述：延迟时间，默认为0。            *&#x2F;            &#x2F;&#x2F; constructor（构造方法）            &#x2F;&#x2F; 在根据传入参数初始化组件之前，构造方法就会被调用。所以说，在构造方法中你可以进行数组初始化等操作。            &#x2F;&#x2F; buildRendering（渲染组件）            &#x2F;&#x2F; dijit._TemplatedMixin提供buildRendering实现你想要实现的组件。此方法执行后，模板会被加载、节点会被创建、事件也会被绑定，最终的结果就是完成节点的展示。如果你没有混入类dijit._TemplateMinxin（通常OOTB dijit会去做），而且希望自己去渲染组件（例如：简化一个组件，或者更换系统模板），你就可以在这个方法中实现。            &#x2F;&#x2F; API中描述：构造组件的UI，并应用到this.domNode。大多数需要重写这个方法的组件都需要继承类dijit._TemplateMinxin。            &#x2F;&#x2F; setters are called（执行setXXX方法）            &#x2F;&#x2F; 类中定义的_setXXX方法会在此时被执行，不管在构造函数中或者为non-null non-blank non-zero类型数据设定默认值，这个方法都会执行。            &#x2F;&#x2F; postCreate（创建组件）            &#x2F;&#x2F; 这个方法是一个组件创建成功的关键步骤，这个组件已经被渲染（注意：如果是容器，那么容器内的组件还未被渲染），并且此组件还未依附到一个DOM节点上，所以在这个方法中你不能进行任何布局相关的计算。            &#x2F;&#x2F; API描述：在组件片创建之后执行，但是不一定已经添加到HTML文档中（通过placeAt()指定依附节点），这个方法不包括管理大小和位置的任何计算。            &#x2F;&#x2F; startup()            &#x2F;&#x2F; 如果你确认所有的子组件已经完成解析、创建，你就可以调用startup()方法。这个方法通常用于布局相关的的组件，例如：BorderContainer。如果组件需要通过JS进行布局计算，那么就可以在startup()中调用resize()方法进行布局处理。            &#x2F;&#x2F; API描述：在组件片已经添加到文档之后执行，并且所有相关的组件已经执行完postCreate()方法。注意：startup()方法可能在组件隐藏的时候被调用，例如：一个隐藏状态的对话框dijit&#x2F;Dialog，或者一个隐藏状态的Tab页dijit&#x2F;layout&#x2F;TabContainer，对于这些组件，如果你想重新布局，最好将相关代码放到resize()方法中，并且继承dijit&#x2F;layout&#x2F;_LayoutWidget，当组件显示的时候，resize()方法就会被调用。            &#x2F;&#x2F; 例子            var button = new Button({                label: &#39;Button2&#39;,                onClick: function () { console.log(&quot;Button2 Clicked.&quot;); }            }, &quot;btn2&quot;);            button.startup();            &#x2F;**            * destroy(preserveDom) 此方法可以进行销毁数据，一般父类都会自动的调用此方法销毁对象，但不包括对象的后代。            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将仅保留原始DOM结构。 注意：这不适用于_TemplatedMixin小部件            *&#x2F;            &#x2F;&#x2F;例子            var widget = new TextBox({ name: &quot;firstname&quot; }, &quot;inputId&quot;);            widget.destroy();            dijit.byId(&quot;dijitId&quot;).destroy();            &#x2F;**            * destroyDescendants(preserveDom) 递归销毁这个小部件及其后代的子节点            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则preserveDom属性将传递给所有后代窗口小部件的.destroy（）方法。 不适用于_Templated小部件。            *&#x2F;            &#x2F;**            * destroyRecursive(preserveDom) 销毁此小部件及其后代            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将使原始DOM结构独立于后代Widgets。 注意：这不适用于dijit._TemplatedMixin小部件。            *&#x2F;            &#x2F;**            * destroyRendering(preserveDom) 销毁与此窗口小部件关联的DOM节点。            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将在销毁期间单独保留原始DOM结构。 注意：这不适用于_TemplatedMixin小部件。            *&#x2F;            &#x2F;**            * get(name) 从小部件获取某个属性的值。            * @param: name            *         类型：undefined            *         描述：要获取值的属性名。            *&#x2F;            &#x2F;**            * getChildren()  返回包含此部件的所有直接子部件的简单数组，不会返回所有后代，而只是直接返回子项，无法使用foreach遍历。            *&#x2F;            &#x2F;**            * getParent() 返回部件的父部件。            *&#x2F;            &#x2F;**            * isFocusable() 如果此部件当前可以聚焦则返回true，否则返回false            *&#x2F;            &#x2F;**            * placeAt(reference,position) 根据标准domConstruct.place（）约定将此部件放在DOM中的某个位置。            * @param: reference            *         类型：String | DomNode | DocumentFragment | dijit&#x2F;_WidgetBase            *         描述：窗口小部件，DOMNode，DocumentFragment，部件或DOMNode的ID            * @param: position            *         类型：String | Int            *         描述：可选的            *               如果引用是窗口小部件（或窗口小部件的id），并且该窗口小部件具有“.addChild”方法，则会调用它将此窗口小部件实例传递到该方法，并提供传递的可选位置索引。 在这种情况下，position（如果指定）应该是一个整数。            *               如果引用是DOMNode（或id匹配DOMNode而不是小部件），则position参数可以是数字索引或字符串“first”，“last”，“before”或“after”，与dojo &#x2F; dom相同-construct::地方（）。            *&#x2F;            &#x2F;&#x2F; Example 1            &#x2F;&#x2F; create a Button with no srcNodeRef, and place it in the body:            var button = new Button({ label: &quot;click&quot; }).placeAt(win.body());            &#x2F;&#x2F; now, &#39;button&#39; is still the widget reference to the newly created button            button.on(&quot;click&quot;, function (e) { console.log(&#39;click&#39;); });            &#x2F;&#x2F; Example 2            &#x2F;&#x2F; create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:            var button = new Button({}, &quot;src&quot;).placeAt(&quot;wrapper&quot;);            &#x2F;&#x2F; Example 3            &#x2F;&#x2F; place a new button as the first element of some div            var button = new Button({ label: &quot;click&quot; }).placeAt(&quot;wrapper&quot;, &quot;first&quot;);            &#x2F;&#x2F; Example 4            &#x2F;&#x2F; create a contentpane and add it to a TabContainer            var tc = dijit.byId(&quot;myTabs&quot;);            new ContentPane({ href: &quot;foo.html&quot;, title: &quot;Wow!&quot; }).placeAt(tc);            &#x2F;**            * set(name,value) 设置部件某个属性。            * @param: name            *         类型：undefined            *         描述：要设置的属性名。            * @param: value            *         类型：undefined            *         描述：要设置的属性值。            *&#x2F;            &#x2F;**            * toString() 返回表示窗口小部件的字符串。            *&#x2F;            &#x2F;**            * watch(name,callback) 检测属性是否变更。            * @param: name            *         类型：String            *         描述：可选。表示要监视的属性。如果省略，将监视所有属性            * @param: callback            *         类型：Function            *         描述：属性更改时要执行的函数。             *&#x2F;            &#x2F;&#x2F;事件            &#x2F;**            * onBlur() 当部件因为焦点移动到其外部或者用户在其外部的某处单击或者窗口小部件被隐藏而停止“活动”时调用。            *&#x2F;            &#x2F;&#x2F; Example 1            var btn = new Button();            &#x2F;&#x2F; when &#x2F;my&#x2F;topic is published, this button changes its label to            &#x2F;&#x2F; be the parameter of the topic.            btn.subscribe(&quot;&#x2F;my&#x2F;topic&quot;, function (v) {                this.set(&quot;label&quot;, v);            });            &#x2F;**            * onFocus() 当部件因为它或其内部的窗口小部件具有焦点或者最近被单击而开始“活动”时调用。            *&#x2F;            &#x2F;&#x2F; Example 1            var btn = new Button();            &#x2F;&#x2F; when &#x2F;my&#x2F;topic is published, this button changes its label to            &#x2F;&#x2F; be the parameter of the topic.            btn.subscribe(&quot;&#x2F;my&#x2F;topic&quot;, function (v) {                this.set(&quot;label&quot;, v);            });            &#x2F;&#x2F;widget例子            var te = new test({}, &quot;base&quot;);            setTimeout(() =&gt; {                te.destroy(true);            }, 1000);        })</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> dojoJs </tag>
            
            <tag> widget </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--Deferred对象</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Deferred%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Deferred%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dojo.Deferred管理异步线程（回调）之间的通信。 dojo.Deferred封装了一系列回调以响应可能尚未可用的值。 所有dojo.xhr*函数都使用此类(Deferred)，其他许多函数也是如此，例如dojo.io.script。<a id="more"></a><br><pre><code>require([            &#39;dojo&#39;,            &#39;dojo&#x2F;_base&#x2F;Deferred&#39;,            &#39;dojo&#x2F;dom&#39;        ], function (dojo, Deferred, dom) {            &#x2F;&#x2F; 官方：从1.09开始不再建议使用dojo&#x2F;_base&#x2F;Deferred，改用dojo&#x2F;Deferred.            &#x2F;&#x2F; dojo.Deferred是一个对象，允许用户为可能无法立即完成的任务分配成功和错误条件的回调函数。             &#x2F;&#x2F; 这些任务通常是通过调用dojo.xhrGet和其他异步操作的IO函数生成的。            &#x2F;&#x2F; 基本前提是这个异步任务（甚至是同步任务）可以返回dojo.Deferred的实例。然后，用户可以调用            &#x2F;&#x2F; then()来为Deferred分配回调函数，回调函数可以有两个(Deferred.then(success_callback, error_callback))。            &#x2F;&#x2F; 如果在执行Deferred之后调用then()函数，则Deferred将立即根据任务结果(成功或错误)调用相应的            &#x2F;&#x2F; 回调函数。一般then()的第一个参数为返回成功时执行的回调函数，第二个参数为返回错误时执行的回            &#x2F;&#x2F; 调函数并且是可选的。            &#x2F;&#x2F; 使用dojo.Deferred非常简单。当你想提供一个函数作为返回时调用，你只需调用then()并            &#x2F;&#x2F; 将then()交给一个函数，以便在触发Deferred时执行。如果你想创建一个Deferred，则只需            &#x2F;&#x2F; new一个实例并将其返回给调用者。当Deferred完成时将调用callback或者errback，此时的回调函数            &#x2F;&#x2F; 返回的又是一个Deferred对象，所以可以多次使用回调函数直至你想要的结果。            &#x2F;&#x2F;创建和调用Deferred            var deferred = new Deferred();            setTimeout(function () {                deferred.resolve({                    success: true                });            }, 1000);            console.log(deferred);            &#x2F;&#x2F;在Deferred触发时指定要触发的回调            &#x2F;&#x2F; var deferred = someAsyncFunction();            &#x2F;&#x2F; deferred.then(            &#x2F;&#x2F;     function (value) {            &#x2F;&#x2F;         &#x2F;&#x2F; Do something on success.            &#x2F;&#x2F;     },            &#x2F;&#x2F;     function (error) {            &#x2F;&#x2F;         &#x2F;&#x2F; Do something on failure.            &#x2F;&#x2F;     }            &#x2F;&#x2F; );            &#x2F;&#x2F; when()方法            &#x2F;&#x2F; when() 函数是与Deferred对象交互的有用工具，因为它可以提供异步Deferred和正常同步值之间的规范化。            &#x2F;&#x2F; 在Dojo 1.7中，when函数作为dojo &#x2F; _base &#x2F; Deferred模块返回（也是Deferred构造函数）的成员公开，            &#x2F;&#x2F; 但在Dojo 1.8中，模块已经移动到自己的位置。            Deferred.when(4, print); &#x2F;&#x2F; this will print 4 immediately            function print(value) {                console.log(value);            };            var fourAsync = new Deferred();            Deferred.when(fourAsync, print); &#x2F;&#x2F; this will print 4, one second later when the Deferred is resolved            setTimeout(function () {                fourAsync.resolve(4);            }, 1000);            &#x2F;&#x2F; Deferred API基于promise的概念，它为最终完成异步操作提供了通用接口。 promise的动机从根本上讲是创建一个            &#x2F;&#x2F; 关注点的分离，允许人们在同步代码中实现与异步代码相同类型的调用模式和逻辑数据流。Promise的参数允许是纯粹            &#x2F;&#x2F; 的函数。 如果实现从同步切换到异步（或反之亦然），则不应该更改调用的参数。             &#x2F;&#x2F; Deferred是一种promise，它提供了通过成功结果或错误来履行 promise的方法。 使用Dojo的promises最重要的方            &#x2F;&#x2F; 法是then（）方法，它遵循CommonJS提出的promise API。 一个then()例子被调用后会返回一个新的promise，表示            &#x2F;&#x2F; 执行回调的结果。 回调永远不会影响原始的promises值。            &#x2F;&#x2F; 允许回调自己返回promise，因此可以轻松地构建复杂的事件序列。            &#x2F;&#x2F; Deferred的创建者可以指定一个cancel函数。 如果在Deferred被触发之前调用Deferred.canceler回调函数，则这个            &#x2F;&#x2F; Deferred会被取消，停止执行。例如可以使用它来实现XMLHttpRequest请求中止。请注意，cancel将使用CancelledError            &#x2F;&#x2F; 类型来触发Deferred（除非你的canceller返回另一种error），因此errbacks回调函数应做好取消Deferred错误的准备。            &#x2F;&#x2F;例子            createDeferred = function () {                &#x2F;&#x2F; Create a deferred and set it to fire in 1 second.                var deferred = new Deferred();                setTimeout(function () {                    deferred.resolve({                        called: true                    });                }, 1000);                dom.byId(&quot;response&quot;).innerHTML = &quot;Created a deferred.&quot;;                &#x2F;&#x2F; Add a callback that changes the displayed message after it fires.                deferred.then(function () {                    dom.byId(&quot;response&quot;).innerHTML = &quot;Deferred has fired.&quot;;                });            };            &#x2F;&#x2F; then(resolvedCallback,errorCallback,progressCallback)            &#x2F;&#x2F; then()方法是在Deferred执行后给三个状态(resolve、error、progress，其中error包括reject和cancel)添加回调函            &#x2F;&#x2F; 数的方法。一共可设置三个回调函数，第一参数在调用resolve后回调，第二参数在调用reject和cancel后            &#x2F;&#x2F; 回调，第三参数在调用progress后回调。所有参数都是可选的，忽略非函数值。progressHandler不仅是一个可选参数，            &#x2F;&#x2F; 而且progress事件也是可选的。 promise提供者不需要创建进度事件。            &#x2F;&#x2F; 此方法在resolvedCallback或者errorCallback执行完成时返回一个新的promise，所以可以实现链式操作。回调函数返回            &#x2F;&#x2F; 的值就是promise返回的结果，如果回调引发错误，则返回的promise将会变为错误状态。            &#x2F;&#x2F;例子            asyncComputeTheAnswerToEverything().                then(addTwo).                then(printResult, onError);            &#x2F;&#x2F; 其他的一些方法            &#x2F;&#x2F; 1、resolve：该deferred完成。            &#x2F;&#x2F; 2、reject：该deferred发生错误。            &#x2F;&#x2F; 3、cancel：取消所有回调，即不再关心该deferred对象。            &#x2F;&#x2F; 4、progress：更新deferred对象状态。            &#x2F;&#x2F; 5、isResolved：若调用过resolve函数返回true            &#x2F;&#x2F; 6、isRejected：若调用过reject函数返回true            &#x2F;&#x2F; 7、isFulfilled：若调用过resolve、reject或cancel三者之一返回true            &#x2F;&#x2F; 8、isCanceled：若调用过cancel函数返回true        })</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> dojoJs </tag>
            
            <tag> Deferred </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--创建类的工具declare</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7declare/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7declare/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;declare(className,superclass,props) 是创建类的基础，es6之前js并不支持创建类，没有关键词class和extends.declare允许开发者实现多继承，从而创建灵活的有弹性的代码，避免重复写代码。<a id="more"></a><br>@param: className<br>&emsp;&emsp;类型: String<br>&emsp;&emsp;描述: 可选。className参数是要创建的这个类的名字，也包括它的命名空间。<br>&emsp;&emsp;&emsp;&emsp;命名类（给定了className, 相对的为匿名类， Named Class）的名字<br>&emsp;&emsp;&emsp;&emsp;会存在于全局作用域， className也可以通过命名空间来表示继承链。<br>&emsp;&emsp;&emsp;&emsp;当省略参数时，创建的类为匿名类，需要使用变量接收。匿名类只在给<br>&emsp;&emsp;&emsp;&emsp;定的作用域有效。<br>@param: superclass<br>&emsp;&emsp;类型: Function | Function[]<br>&emsp;&emsp;描述: SuperClass 参数可以为null(但不能省略)、 单个已存在的类或者多个<br>&emsp;&emsp;&emsp;&emsp;类组成的数组。<br>@param: props<br>&emsp;&emsp;类型: Object<br>&emsp;&emsp;描述: 包含这个类原型方法和原型属性的一个对象。 此参数提供的属性或方法<br>&emsp;&emsp;&emsp;&emsp;如果跟被继承的类的属性或方法同名，那么将会被优先使用。<br><pre><code>require([            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &#39;dojo&#x2F;_base&#x2F;lang&#39;,            &#39;dojo&#x2F;dom&#39;,            &quot;dijit&#x2F;form&#x2F;Button&quot;,            &quot;dojo&#x2F;domReady!&quot;        ], function (declare, lang, dom, Button) {            &#x2F;&#x2F; className(类名)            &#x2F;&#x2F; 命名类            declare(&quot;mynamespace.Person&quot;, null, {                &#x2F;&#x2F; Custom properties and methods here                method: function () {                    console.log(&quot;命名类&quot;);                }            })            var per = new mynamespace.Person();            per.method();            &#x2F;&#x2F; 匿名类  需要变量名去接收            var Person = declare(null, {                &#x2F;&#x2F; Custom properties and methods here                method: function () {                    console.log(&quot;匿名类&quot;);                }            })            var per = new Person();            per.method();            &#x2F;&#x2F; SuperClass(超类)，继承的优先级从左至右依次升高，若果出现重复属性或方法时，            &#x2F;&#x2F; 时，优先级高的将会被保留，低的将会被覆盖。可以通过declare()的第三个参数添加            &#x2F;&#x2F; 相同的属性或方法名来覆盖你想覆盖掉的东西。            &#x2F;&#x2F;不继承            console.log(&quot;------------不继承-----------&quot;)            declare(&quot;myClass&quot;, null, {                text: &quot;不继承&quot;            });            var myInst = new myClass();            console.log(myInst);            console.log(myInst.text);            &#x2F;&#x2F;单继承            console.log(&quot;------------单继承-----------&quot;)            declare(&quot;mySubClass&quot;, myClass, {                text: &quot;单继承&quot;            });            var myInst = new mySubClass();            console.log(myInst);            console.log(myInst.text)            &#x2F;&#x2F; 多继承            console.log(&quot;------------多继承-----------&quot;)            declare(&quot;myFirstClass&quot;, null, {                num1: &quot;1&quot;,                prop: &quot;a&quot;            });            declare(&quot;mySecondClass&quot;, null, {                num2: &quot;2&quot;,                prop: &quot;b&quot;            });            declare(&quot;myThirdClass&quot;, null, {                num3: &quot;3&quot;,                prop: &quot;c&quot;            });            var Obj = {                num4: &quot;4&quot;,                prop: &quot;d&quot;            }            declare(&quot;myMultiSubClass&quot;, [myFirstClass, mySecondClass, myThirdClass], Obj);            var myInst = new myMultiSubClass();            console.log(myInst);            console.log(myInst.num1 + myInst.num2 + myInst.num3 + myInst.num4 + &quot;,&quot; + myInst.prop);            &#x2F;*                 从myInst打印的情况可以看出，优先级的具体表现就是原型链继承的先后问题，Obj处于                原型链的首位，所以优先级最高，原型链依次往后分别是myThirdClass、mySecondClass、                myFirstClass，前面提到出现重复项时优先级高的class将会覆盖掉优先级低的，其实                严格来讲并不是这样，根据原型链的特性，当检索一个对象实例的属性时，会首先检查实                例自己本身的属性，如果没有，会查找按顺序原型链，如果原型链中某一个对象出现有这个属性，                则直接返回这个属性的值，不再进行查找，如果整个原型链都没有这个属性则返回undefine。                也正是因为这样，多继承类出现重复定义项时，排列在原型链前的将会被直接返回，因为                已经返回，所以永远得不到原型链后面的重复项的值，这个并不是覆盖，重复项还是处于                原型链中，只是得不到而已。                我们可以做个实验直接获取myFirstClass的prop属性，查看它是否还存在以及属性值是                否被改变。            *&#x2F;            console.log(myInst.__proto__.__proto__.__proto__.__proto__.prop)&#x2F;&#x2F;myFirstClass中的prop属性值仍然为&quot;a&quot;            &#x2F;&#x2F; 属性和方法对象            &#x2F;&#x2F; declare方法的最后的参数是包含这个类原型方法和原型属性的一个对象。 此参数提供的            &#x2F;&#x2F; 属性或方法如果跟被继承的类的属性或方法同名，那么将会被优先使用。            &#x2F;&#x2F; 拥有属性和方法的类            declare(&quot;MyClass&quot;, null, {                myProperty1: 12,                myOtherProperty: &quot;Hello&quot;,                myMethod: function () {                    console.log(&quot;World&quot;);                    return result;                }            });            &#x2F;&#x2F;类的创建和继承例子            &#x2F;&#x2F;使用declare()继承dijit&#x2F;form&#x2F;Button组件，并添加label和onClick属性。            declare(&quot;newButton&quot;, Button, {                label: &quot;My Button&quot;,                onClick: function (e) {                    console.log(&quot;I was clicked!&quot;);                }            })            var myButton = new newButton({}, &quot;declare&quot;).startup();            &#x2F;&#x2F; 构造函数 constructor            &#x2F;&#x2F; 类中特别的一个方法就是constructor方法，constructor方法会在类的实例化时触发，在            &#x2F;&#x2F; 新对象的作用域名内执行。如果在constructor中使用this，则这个this则会指向这个类的            &#x2F;&#x2F; 实例，而不是类。constructor接受实例化指定的参数。            console.log(&quot;--------------构造函数-------------&quot;)            declare(&quot;Twitter&quot;, null, {                username: &quot;defaultUser&quot;,                constructor: function (args) {                    declare.safeMixin(this, args);&#x2F;&#x2F;将传入的参数混入到实例对象中                }            })            var myInst = new Twitter();            console.log(myInst.username);&#x2F;&#x2F;输出defaultUser            &#x2F;&#x2F;创建并传入一个对象            var myInst = new Twitter({                username: &quot;Sparrow&quot;            });            console.log(myInst.username);&#x2F;&#x2F;输出Sparrow            &#x2F;&#x2F; 如果继承的原型中属性指向Object或者Array，创建的实例将会指向同一个值。下面来探讨一            &#x2F;&#x2F; 种数据被意外修改的情况            var arr = [1, 2, 3, 4];            declare(&quot;myClass&quot;, null, {                num: arr,                prop: &quot;aaa&quot;            });            var myInst1 = new myClass();            var myInst2 = new myClass();            myInst1.prop = &quot;bbb&quot;; &#x2F;&#x2F;修改num属性            console.log(myInst1.prop); &#x2F;&#x2F; bbb            console.log(myInst2.prop); &#x2F;&#x2F; aaa            &#x2F;&#x2F; 此时实际上时给myInst新增了一个prop属性，并没有操作原型链中的prop属性，所以myInst2.prop并没有被修改            myInst1.__proto__.prop = &quot;bbb&quot;;            console.log(myInst1.prop); &#x2F;&#x2F; bbb            console.log(myInst2.prop); &#x2F;&#x2F; bbb            &#x2F;&#x2F; 操作原型链时，其他实例也会受到影响，这种情况一般不会发生            myInst1.num = [4, 5, 6, 7];            console.log(myInst1.num); &#x2F;&#x2F; [4,5,6,7]            console.log(myInst2.num); &#x2F;&#x2F; [1,2,3,4]            &#x2F;&#x2F; 此时实际上时给myInst新增了一个num属性，并没有操作原型链中的num属性，所以myInst2.num并没有被修改            delete myInst1.num;&#x2F;&#x2F;删除num属性，以下的myInst1已经没有这个属性            myInst1.num.push(5);            console.log(myInst1.num); &#x2F;&#x2F; [1,2,3,4,5]            console.log(myInst2.num); &#x2F;&#x2F; [1,2,3,4,5]            &#x2F;&#x2F; push一个元素进myInst1.num时，myInst2.num也受到了影响，因为实例本身没有这个属性，            &#x2F;&#x2F; 所以push操作的实际上是原型链中的num，为了避免这种非故意的修改共享数据，对象的属性            &#x2F;&#x2F; 声明为null，然后在构造函数constructor中对它进行初始化。当然这是网上的一种说法，经            &#x2F;&#x2F; 过实践得出这说法不完全可靠。            console.log(&quot;-------------使用构造函数改造--------------&quot;)            &#x2F;&#x2F;情况1            var arr2 = [1, 2, 3, 4];            declare(&quot;myClass&quot;, null, {                numArr: null,                prop: null,                constructor: function (arr) {                    this.numArr = arr;                    this.prop = &quot;aaa&quot;;                }            });            var myInst1 = new myClass([1, 2, 3, 4]);            var myInst2 = new myClass([1, 2, 3, 4]);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4]            &#x2F;&#x2F; 如果使用传参的方式进行初始化，并且是匿名数组，那么改变myInst1时并不会对myInst2造成影响            var myInst1 = new myClass(arr2);            var myInst2 = new myClass(arr2);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4，5]            &#x2F;&#x2F; 如果使用传递的参数不是匿名数组，那么同样会出现误改数据的情况            &#x2F;&#x2F; 原因很简单，无论怎样初始化，数组类型的引用特性是不会改变的，&quot;this.numArr = arr2&quot;只是起            &#x2F;&#x2F; 到一个把numArr指向arr2的作用，无论this的对象是谁。可以了解一下浅拷贝和引用类型的特性            &#x2F;&#x2F; 便可知道。若果要使用共享的数据而不希望出现误改，根本的解决办法是使用深度拷贝，把arr2的值            &#x2F;&#x2F; 完完整整的拷贝过来而不是使用指针。但这样的一个缺点就是当arr或者obj占用空间很大时，使用            &#x2F;&#x2F; 深度拷贝之后的空间会翻倍，所以应该谨慎使用，或者使用完之后应该及时销毁。            declare(&quot;myClass&quot;, null, {                numArr: null,                prop: null,                constructor: function (arr) {                    this.numArr = lang.clone(arr);&#x2F;&#x2F;clone()是dojo&#x2F;_base&#x2F;lang的一个深度拷贝工具。                    this.prop = &quot;aaa&quot;;                }            });            var myInst1 = new myClass(arr2);            var myInst2 = new myClass(arr2);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4]            &#x2F;&#x2F; this.inherited() 虽然重写一个方法确实有用， 但每一个类的的构造函数都应该执行它继承链中的            &#x2F;&#x2F; 父类构造函数，以保持它原始的功能。 这样this.inherited(arguments)语句就派上用场了。              &#x2F;&#x2F; this.inherited(arguments)语句调用父类的同名方法。             var A = declare(null, {                myMethod: function () {                    console.log(&quot;Hello!&quot;);                }            });            var B = declare(A, {                myMethod: function () {                    &#x2F;&#x2F; 调用父类A中同名的方法                    this.inherited(arguments); &#x2F;&#x2F; arguments指的就是在父类A中定义的myMethod                    console.log(&quot;World!&quot;);                }            });            var myB = new B();            myB.myMethod();            &#x2F;&#x2F;      Hello!            &#x2F;&#x2F;      World!        })</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> declare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--通用工具lang</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7lang/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7lang/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dojo/base/lang模块是一个通用工具模块，主要提供以下的工具函数<br><a id="more"></a><br><pre><code>require([&#39;dojo&#39;, &#39;dojo&#x2F;_base&#x2F;lang&#39;, &#39;dojo&#x2F;_base&#x2F;declare&#39;, &#39;dojo&#x2F;dom&#39;, &#39;dojo&#x2F;dom-attr&#39;, &quot;dojo&#x2F;domReady!&quot;],    function (dojo, lang, declare, dom, attr) {        &#x2F;*            clone(src)  克隆任何对象或者元素节点，返回一个全新的匿名对象，该对象具有被克隆对象的所有属性和方法，                        而不是指向性的，属于深拷贝。注意：无法克隆循环结构。                @param: src                         类型: anything                        描述: 克隆目标.        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;------------------------- lang.clone -----------------------------&#39;)        var Obj1 = {            firstName: &#39;李&#39;,            lastName: &#39;小龙&#39;        }        var Obj2 = lang.clone(Obj1);        console.log(Obj2);        Obj2.firstName = &#39;张&#39;;        Obj2.lastName = &#39;学友&#39;;        console.log(Obj2);        console.log(Obj1);&#x2F;&#x2F;修改Obj2后Obj1并未受到影响，因为是深拷贝        var node = dom.byId(&#39;someNode&#39;);        var newNode = lang.clone(node);        &#x2F;&#x2F;attr.set给newNode添加属性&quot;id:someNewId&quot;        var newNode = attr.set(newNode, &quot;id&quot;, &quot;someNewId&quot;);        &#x2F;&#x2F;把newNode插在node节点之前，两者为兄弟节点        dojo.place(newNode, node, &quot;before&quot;);        &#x2F;*            delegate(obj, props) 返回一个新的匿名对象，该对象指向(代理)obj对象。当props对象            不为空时将其混入新对象中，并且会进行覆盖。新对象能够访问props的原有属性和方法。                @param: obj                         类型: Object                        描述: 被代理的对象。                @param: props                         类型: Object                        描述: 该对象的属性将会被添加至delegate()返回的对象。        *&#x2F;        &#x2F;&#x2F;创建实例        console.log(&#39;------------------------- lang.delegate -----------------------------&#39;);        var anOldObject = { bar: &quot;baz&quot; };        &#x2F;&#x2F; 创建anNewObject对象作为anOldObject对象的代理对象，并且增加thud:&#39;xyzzy&#39;属性。        var anNewObject = lang.delegate(anOldObject, { thud: &quot;xyzzy&quot; });        console.log(anNewObject);        console.log(anNewObject.bar === &quot;baz&quot;);&#x2F;&#x2F; true        &#x2F;&#x2F; 关键 增加thud属性时并没有影响anOldObject对象，这就是代理的作用，希望给对象新增方法或属性        &#x2F;&#x2F; 进行下一步操作,然而不想改变原有对象的前提下，可以使用delegate()方法实现        console.log(anOldObject.thud === &quot;xyzzy&quot;); &#x2F;&#x2F; false        console.log(anNewObject.thud === &quot;xyzzy&quot;); &#x2F;&#x2F; true         anOldObject.bar = &quot;thonk&quot;;        console.log(anNewObject.bar === &quot;thonk&quot;); &#x2F;&#x2F; true        &#x2F;&#x2F; 源码        delegate: (function () {            &#x2F;&#x2F; 临时构造函数            function TMP() { }            &#x2F;&#x2F; 返回一个匿名函数，该函数其实就是dojo.delegate函数            return function (obj, props) {                TMP.prototype = obj;                var tmp = new TMP();                &#x2F;&#x2F; 虽然TMP.prototype重新置为null，但是tmp对象已经创建出来了，其[[prototype]]属性已经指向了obj，                &#x2F;&#x2F; 所以通过tmp对象可以访问到obj对象中的属性                TMP.prototype = null;                &#x2F;&#x2F; 如果props存在，则将props混入tmp对象中，所以tmp对象中就有了props对象的所有属性                if (props) {                    d._mixin(tmp, props);                }                return tmp; &#x2F;&#x2F; 返回tmp对象            };        });        &#x2F;*            exists(name, obj) 返回值：布尔类型。判断对象是否存在某个方法或属性。                @param: name                         类型: String                        描述: &#39;A.B.C&#39;形式的对象路径.                @param: obj                         类型: Object                        描述: 可选。可使用该参数指定name的根路径。                            参数为空时默认使用 dojo&#x2F;_base&#x2F;kernel::global ，通常是当前的window对象。        *&#x2F;        &#x2F;&#x2F;实例        &#x2F;&#x2F; define an object        console.log(&#39;------------------------- lang.exists -----------------------------&#39;)        var foo = {            bar: {}        };        &#x2F;&#x2F; 从全局作用域判断属性是否存在        console.log(lang.exists(&quot;foo.bar&quot;)); &#x2F;&#x2F; true        console.log(lang.exists(&quot;foo.bar.baz&quot;)); &#x2F;&#x2F; false        &#x2F;&#x2F; 从foo作用域判断属性是否存在        console.log(lang.exists(&quot;bar&quot;, foo)); &#x2F;&#x2F; true        console.log(lang.exists(&quot;bar.baz&quot;, foo)); &#x2F;&#x2F; false        &#x2F;*            extend(ctor,props) 将props对象的所有属性和方法添加到构造函数的原型中，使通过构造函数创建                的实例都可以使用这些属性和方法。                @param: ctor                         类型: Object                        描述: 要扩展的目标构造函数。                @param: props                         类型: Object                        描述: 混入ctor构造函数原型的一个或者多个对象。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;------------------------- lang.extend -----------------------------&#39;)        function per(name) {            this.name = name;        };        lang.extend(per, {            prop: &quot;穷的只剩下钱&quot;,            method: function () {                console.log(&quot;除了赚钱什么也不会&quot;)            }        })        var Obj = new per(&quot;股民巴菲特&quot;);        console.log(Obj.name);        console.log(Obj.prop);        Obj.method();        &#x2F;*            getObject(name,create,context) 返回属性或者方法的值。从点分隔的字符串中获取属性，如&quot;A.B.C&quot;。                @param: name                         类型: String                        描述: &quot;A.B.C&quot;形式的属性的路径。                @param: create                         类型: Boolean                        描述: 可选。默认为false。如果为true，name属性未定义时，则会在该路径创建该属性,如果该                                路径不存在，则会沿着该路径的每一级创建一个对应的空对象，直至路径尽头为止。                @param: context                         类型: Object                        描述: 可选。可使用该参数指定name的根路径，降低代码繁冗度。参数为空时默认使用                                dojo&#x2F;_base&#x2F;kernel::global ，通常是当前的window对象。        *&#x2F;        console.log(&#39;------------------------- lang.getObject -----------------------------&#39;)        &#x2F;&#x2F; 定义一个全局变量        var bar = {}        obj = {            bar: &quot;Russia 2018&quot;,            &#x2F;&#x2F; bar: bar        };        console.log(lang.getObject(&quot;obj.bar&quot;)); &#x2F;&#x2F; returns &quot;Russia 2018&quot;        &#x2F;&#x2F; 获取foo.baz属性, 如果不存在就创建这个属性        lang.getObject(&quot;obj.baz&quot;, true); &#x2F;&#x2F; 返回一个空的对象baz至路径obj中         lang.getObject(&quot;obj.baz.baz.baz.baz.baz&quot;, true); &#x2F;&#x2F; 每一个不存在的baz都相应的被创建，并且返回至obj。         console.log(obj);        &#x2F;*            obj = {                bar: &quot;Russia 2018&quot;,                buz: {                    buz: {                        buz: {                            buz: {                                buz: {                                }                            }                        }                    }                }            }        *&#x2F;        &#x2F;&#x2F; 定义一个非全局变量        var _obj = {            bar: &quot;Russia 2018&quot;        };        &#x2F;&#x2F; 指定从foo对象中获取bar        console.log(lang.getObject(&quot;bar&quot;, false, _obj)); &#x2F;&#x2F; returns &quot;Russia 2018&quot;        &#x2F;*            hitch(scope,method) 返回一个只在给定作用域内执行的函数。                @param: scope                         类型: Object                        描述: method执行时的作用域，如果method是字符串类型，则scope是包含method的对象。                                如果该参数为null时，则指向全局对象                @param: method                         类型: Function | String...                             描述: 要被挂载到scope内的函数function(){}，或者被挂载到scope内的method的名称。        *&#x2F;        console.log(&#39;------------------------- lang.hitch -----------------------------&#39;)        &#x2F;&#x2F;定义一个对象student        var Student = {            college: &quot;MIT&quot;,            getCollege: function () {                &#x2F;&#x2F;我们希望它能返回Student对象的college属性，即希望this指向Student本身                return this.college;            }        }        function printCollege(foo) {            console.log(&quot;College: &quot; + foo());        }        &#x2F;&#x2F; 函数上下文中this的值是函数调用者提供并且由当前调用表达式的形式而定的。         printCollege(Student.getCollege); &#x2F;&#x2F; &quot;College: undefined&quot;, 即 this 的值为 GLOBAL        &#x2F;&#x2F; 使用lang.hitch改变指向        printCollege(dojo.hitch(Student, Student.getCollege));&#x2F;&#x2F;&quot;College: MIT&quot;        printCollege(dojo.hitch(Student, &quot;getCollege&quot;));&#x2F;&#x2F;&quot;College: MIT&quot;        &#x2F;&#x2F;源码        dojo._hitchArgs = function (scope, method &#x2F;*,...*&#x2F;) {            &#x2F;&#x2F;排除第一个和第二个参数后转成一个数组，其实就是将method后面的参数作为目标函数的参数，转成一个数组            var pre = dojo._toArray(arguments, 2);            &#x2F;&#x2F;method是否是字符串类型            var named = dojo.isString(method);            &#x2F;&#x2F;返回一个新函数            return function () {                &#x2F;&#x2F;将这个新函数的的arguments转成数组，注意上下这两个arguments对象是不同的，上一个是属于dojo_hitchArgs函数，下一个是属性于返回的新函数的                var args = dojo._toArray(arguments);                &#x2F;&#x2F;取出目标函数，如果scope不存在，则函数为window[method]                var f = named ? (scope || dojo.global)[method] : method;                &#x2F;&#x2F;将两个参数数组进行连接，形成完整参数数组，这就是为什么通过hitch函数，参数可以分两次传递的原因                &#x2F;&#x2F;这个新函数的返回值就是目标函数执行的返回值，只是this变量进行了替换                return f &amp;&amp; f.apply(scope || this, pre.concat(args)); &#x2F;&#x2F; mixed            }; &#x2F;&#x2F; Function        };        hitch = function (&#x2F;*Object*&#x2F;scope, &#x2F;*Function|String*&#x2F;method &#x2F;*,...*&#x2F;) {            &#x2F;&#x2F;scope就是用于替换this变量的对象；method可以是一个字符串，或者是一个函数，用于指明替换哪个函数的this变量            if (arguments.length &gt; 2) {                &#x2F;&#x2F;如果参数个数多于两个则，调用dojo._hitchArgs函数                return dojo._hitchArgs.apply(dojo, arguments); &#x2F;&#x2F; Function            }            &#x2F;&#x2F;如果method未指定            if (!method) {                method = scope;                scope = null;            }            &#x2F;&#x2F;如果method是字符串类型            if (dojo.isString(method)) {                &#x2F;&#x2F;如果scope不存在则，scope为全局对象，即window                scope = scope || d.global;                if (!scope[method]) { throw ([&#39;dojo.hitch: scope[&quot;&#39;, method, &#39;&quot;] is null (scope=&quot;&#39;, scope, &#39;&quot;)&#39;].join(&#39;&#39;)); }                &#x2F;&#x2F;返回一个新函数，该函数调用scope[method]函数，并使this指向scope                return function () { return scope[method].apply(scope, arguments || []); }; &#x2F;&#x2F; Function            }            &#x2F;&#x2F;如果scope不存在，则直接返回该函数，这时并没有修改this变量            &#x2F;&#x2F;如果scope存在，则直接调用该函数，并使this指向scope            return !scope ? method : function () { return method.apply(scope, arguments || []); }; &#x2F;&#x2F; Function        };        &#x2F;*        mixin(dest,sources) 从sources对象复制&#x2F;添加它的所有属性、方法至dest对象，但不包括        在Object.prototype中发现的任何非标准扩展。如果某个属性指向对象，mixin只做浅拷贝。            @param: dest                     类型: Object                    描述: 复制&#x2F;添加的目标对象            @param: sources                     类型: Object                         描述: 被复制的源对象。        *&#x2F;        &#x2F;&#x2F; 针对mixin浅拷贝的情况设计一个简单实验        &#x2F;&#x2F;引入lang工具        console.log(&#39;--------------------------lang.mixin------------------------------&#39;)        &#x2F;&#x2F; 定义一个被指向的对象        var lastName = {            lastName: &quot;小龙&quot;        };        &#x2F;&#x2F; 定义一个主要对象        var Obj1 = {            &#x2F;&#x2F;这个属性直接赋值            firstName: &quot;李&quot;,            &#x2F;&#x2F;这个属性指向一个对象            lastName: lastName        }        &#x2F;&#x2F;使用mixin复制Obj1给Obj2        var Obj2 = lang.mixin({            firstName: &quot;哈？&quot;        }, Obj1);        &#x2F;&#x2F;查看Obj2的打印情况，输出&quot;李小龙&quot;，目标对象的firstName属性被覆盖        console.log(Obj2.firstName + Obj2.lastName.lastName);        &#x2F;&#x2F;查看Obj1的打印情况，输出&quot;李小龙&quot;        console.log(Obj1.firstName + Obj1.lastName.lastName);        &#x2F;&#x2F;修改Obj2        Obj2.firstName = &quot;张&quot;;        Obj2.lastName.lastName = &quot;学友&quot;;        &#x2F;&#x2F;查看Obj2的打印情况，输出&quot;张学友&quot;        console.log(Obj2.firstName + Obj2.lastName.lastName);        &#x2F;&#x2F;查看Obj1的打印情况，输出&quot;李学友&quot;??名字在Obj2修改的时候，Obj1的也跟着变化，因为指向的都是同一个值。这就是引用的特性        console.log(Obj1.firstName + Obj1.lastName.lastName);        &#x2F;&#x2F;例子二        declare(&quot;acme.Base&quot;, null, {            constructor: function (properties) {                &#x2F;&#x2F; property configuration:                lang.mixin(this, properties);                &#x2F;&#x2F;  ...            },            quip: &quot;I wasn&#39;t born yesterday, you know - I&#39;ve seen movies.&quot;,            &#x2F;&#x2F; ...        });        &#x2F;&#x2F; create an instance of the class and configure it        var b = new acme.Base({ quip: &quot;That&#39;s what it does!&quot; });        console.log(b.quip);        &#x2F;&#x2F;源码        mixin = function (&#x2F;*Object*&#x2F;obj, &#x2F;*Object...*&#x2F;props) {            if (!obj) { obj = {}; }&#x2F;&#x2F;如果obj目标对象不存在，则赋予一个空对象，防止异常            for (var i = 1, l = arguments.length; i &lt; l; i++) {&#x2F;&#x2F;遍历混入源对象，注意索引从1开始，因为需要排除obj目标对象                d._mixin(obj, arguments[i]);&#x2F;&#x2F;调用真正实现混入的_mixin函数            }            &#x2F;&#x2F;返回原来的目标对象            return obj; &#x2F;&#x2F; Object        }        var extraNames, extraLen, empty = {};        &#x2F;&#x2F;如果toString(覆盖从Object继承的toString)不能在for..in循环中遍历到，则extraNames为undefined，如果能则赋值为空列表        for (var i in { toString: 1 }) { extraNames = []; break; }        &#x2F;&#x2F;如果extraNames存在则dojo._extraNames会等于extraNames，即是一个空列表        &#x2F;&#x2F;如果extraNames为undefined，则dojo._extraNames为[&quot;hasOwnProperty&quot;, &quot;valueOf&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;toLocaleString&quot;, &quot;toString&quot;, &quot;constructor&quot;]        dojo._extraNames = extraNames = extraNames || [&quot;hasOwnProperty&quot;, &quot;valueOf&quot;, &quot;isPrototypeOf&quot;,            &quot;propertyIsEnumerable&quot;, &quot;toLocaleString&quot;, &quot;toString&quot;, &quot;constructor&quot;];        extraLen = extraNames.length;&#x2F;&#x2F;获取长度        dojo._mixin = function (&#x2F;*Object*&#x2F; target, &#x2F;*Object*&#x2F; source) {            var name, s, i;            &#x2F;&#x2F;遍历源对象中的属性            for (name in source) {                &#x2F;&#x2F;在混入的时候需要排除从Object继承而来的属性，除非源对象重新定义了从Object继承而来的属性                s = source[name];&#x2F;&#x2F;取出属性值                &#x2F;&#x2F;成立条件有：                &#x2F;&#x2F;1. 目标对象中不存在源对象中的某个属性                &#x2F;&#x2F;2. 目标对象与源对象属性值不相等并且 (该属性不是从Object继承而来或者源对象重新定义了从Object继承而来的属性)                if (!(name in target) || (target[name] !== s &amp;&amp; (!(name in empty) || empty[name] !== s))) {                    &#x2F;&#x2F;将源对象属性值赋给目标对象                    target[name] = s;                }            }            &#x2F;&#x2F; IE doesn&#39;t recognize some custom functions in for..in有些版本的IE对于重新定义从Object继承来而的属性不能识别，所以需要重新判断一次            if (extraLen &amp;&amp; source) {                for (i = 0; i &lt; extraLen; ++i) {                    name = extraNames[i];                    s = source[name];                    if (!(name in target) || (target[name] !== s &amp;&amp; (!(name in empty) || empty[name] !== s))) {                        target[name] = s;                    }                }            }            &#x2F;&#x2F;返回目标对象            return target; &#x2F;&#x2F; Object        }        &#x2F;*            partial(method) 与hitch类似，相当于把hitch()第一个参数置为null，基于hitch实现                @param: method                         类型: Function | String                        描述: 被绑定到某个作用域的方法。        *&#x2F;        console.log(&#39;--------------------------lang.partial------------------------------&#39;)        &#x2F;&#x2F; 实例        console.log(&quot;请在左侧点击按钮查看效果&quot;)        var myClick = function (presetValue, event) {            dojo.place(&quot;&lt;p&gt;&quot; + presetValue + &quot;&lt;&#x2F;p&gt;&quot;, &quot;appendLocation&quot;);        };        dojo.connect(dom.byId(&quot;myButton&quot;), &quot;click&quot;, lang.partial(myClick, &quot;This is preset text!&quot;));        &#x2F;&#x2F; 源码        partial = function (&#x2F;*Function|String*&#x2F;method &#x2F;*, ...*&#x2F;) {            var arr = [null];            &#x2F;&#x2F;将scope置为null            return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); &#x2F;&#x2F; Function        };        &#x2F;*            replace(tmpl,map,pattern) 轻量级的字符串替换、连接的工具函数。                @param: tmpl                         类型: String                        描述: 要进行替换部分内容的字符串模板。                @param: map                         类型: Object | Function                        描述: 提供替换内容的JSON对象。                @param: pattern                         类型: RegEx                    描述: 可选。用于规定什么样的内容将会被替换的正则表达式模板。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.replace------------------------------&#39;)        var output = dojo.replace(            &#x2F;&#x2F; 被处理的字符串模板            &quot;Hello, {name.first} {name.last} AKA {nick}!&quot;,            &#x2F;&#x2F; 替换内容            {                name: {                    first: &quot;Robert&quot;,                    middle: &quot;X&quot;,                    last: &quot;Cringely&quot;                },                nick: &quot;Bob&quot;            }        );        console.log(output);        &#x2F;*            setObject(name,value,context) 根据点分隔字符串路径（如A.B.C）设置对象属性                @param: name                         类型: String                        描述: &#39;A.B.C&#39;形式的对象路径。                @param: value                         类型: anything                        描述: 设置的内容。                @param: context                         类型: Object                        描述: 可选。指定name的根路径，默认GLOBAL。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.setObject------------------------------&#39;)        var family = {            father: &quot;父亲&quot;,            mother: &quot;母亲&quot;        }        &#x2F;&#x2F;指定在family内添加一个children:&quot;children&quot;        lang.setObject(&quot;children&quot;, &quot;孩子&quot;, family);        console.log(family);        &#x2F;&#x2F;缺点，会插到对象子属性的最前面        &#x2F;*              trim(str) 用于移除给定字符串参数的前后空格。                @param: str                         类型: String                        描述: 目标字符串。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.trim------------------------------&#39;)        var word = &quot;   What&#39;s your name? Thor  &quot;;        console.log(&quot;|&quot; + word + &quot;|&quot;);        console.log(&quot;|&quot; + lang.trim(word) + &quot;|&quot;);        &#x2F;&#x2F;不能去除字符串内空格\        &#x2F;&#x2F;isAlien()         console.log(&#39;--------------------------lang.isAlien----------------------------&#39;)        console.log(lang.isAlien(Function));    })    &#x2F;&#x2F; isArray(it) 如果时一个数组则返回真。    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isArrayLike(it) 类似于isArray()但是更加宽容，不严格要求测试对象是不是数组，而是根据对象是否具有    &#x2F;&#x2F; length属性进行判断，例如参数对象和DOM对象，使用isArrayLike()判断会返回true，而使用isArray()则返回false。    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isFunction(it) 如果时函数则返回true    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isObject(it) 如果时Javascript对象则返回ture（包括数组、函数或者Null）    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isString(it) 如果是字符串则返回true    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> dojojs </tag>
            
            <tag> lang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--事件绑定on()</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Aon/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Aon/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;on() 方法在元素上绑定事件，需要引用包dojo/on，通过on方法实现。<a id="more"></a><br>&emsp;&emsp;on方法不需要前缀。包括三个参数。<br>第一个：需要绑定events的元素<br>第二个：event名称<br>第三个：处理event的方法体，这个方法体有只一个参数，为event的对象，包括一些属性和方法，如果需要传递其他参数，将在后面讲到。<br>方法on的返回值是一个简单的对象，只有一个remove方法，执行这个方法，元素就会移除这个event。<br>还有一个方法on.once(element,event name,handler)，参数同on一样，这个方法顾名思义就是只执行一次，在执行了handler后将会自动remove。<br>一个元素可以绑定多个events，每个event按照绑定的先后顺序来执行的。<br><pre><code>require([&quot;dojo&#x2F;on&quot;, &quot;dojo&#x2F;dom&quot;, &quot;dojo&#x2F;dom-style&quot;, &quot;dojo&#x2F;mouse&quot;, &quot;dojo&#x2F;domReady!&quot;],function (on, dom, domStyle, mouse) {    var myButton = dom.byId(&quot;myButton&quot;),        myDiv = dom.byId(&quot;myDiv&quot;);    on(myButton, &quot;click&quot;, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;blue&quot;);    });    on(myDiv, mouse.enter, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;red&quot;);    });    var handler = on(myDiv, mouse.leave, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;&quot;);    });    handler.remove();&#x2F;&#x2F;移除event    on.once(myDiv, mouse.leave, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;&quot;);    });});</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> DojoJs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决windows下命令执行出错:无法将&#39;hexo&#39;项识别为 cmdlet、函数、脚本文件或可运行程序的名称。</title>
      <link href="/2018/07/07/%E8%A7%A3%E5%86%B3windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BA%E9%94%99-%E6%97%A0%E6%B3%95%E5%B0%86-hexo-%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82/"/>
      <url>/2018/07/07/%E8%A7%A3%E5%86%B3windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BA%E9%94%99-%E6%97%A0%E6%B3%95%E5%B0%86-hexo-%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>hexo : 无法将“hexo”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。<a id="more"></a><br>所在位置 行:1 字符: 1<br>+ hexo<br>+ ~~~~<br>    + CategoryInfo          : ObjectNotFound: (hexo:String) [], CommandNotFoundException<br>    + FullyQualifiedErrorId : CommandNotFoundException<br>今天笔者换新电脑后进行资料迁移以及重新配置一遍工作环境，在迁移完这个博客的工程后，在工程中使用hexo new “name”创建新博客时一直报错，系统找不到指定的命令”hexo”，一般情况下出现这种错误有两种错误，一种是没有进行全局安装，另一种是全局安装目录没有加入系统环境变量PATH中。楼主先是测试第一中情况，执行<br><pre><code>npm install -g hexo-cli</code></pre><br>进行全局安装，再次运行hexo new “name”命令，依然报错，执行npm list –depth=0 -global查看当前已经进行全局安装的模块。<br><pre><code>-- hexo-cli@1.1.0</code></pre><br>可见hexo-cli是存在有的，那么我们看看第二种情况。查案看当前的PATH环境变量<br></p><p><div align="center"><img src="../../../../img/7/7/path.png" width="50%" height="50%"></div> <br><br>注意PATH中的第二行，这个其实就是npm的全局安装目录，全局变量模块都存于此目录（C:\Users\用户名\AppData\Roaming\npm）下，所以需要在PATH环境变量中加入此目录路径，那么为什么还会报错呢？其实这里用户名是不存在的，昨天笔者拿到新本子开机心切，随便起了个1111的用户名，后来还是觉得太随便太丑了，就强行改了回来，结果在改名之前就已经安装了编辑器并且安装了node，应该就是当时node配置环境变量时使用了当时的1111用户名，所以才会出项这种情况。所以该回来之后，再执行hexo new “name”</p><p><div align="center"><img src="../../../../img/7/7/result.png" width="80%" height="80%"></div> <br><br>OK，大功告成。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS实战笔记--实现tree组件</title>
      <link href="/2018/07/01/JS%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%AE%9E%E7%8E%B0tree%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/07/01/JS%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%AE%9E%E7%8E%B0tree%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;前些天去面试，被要求用原生JS实现一个能遍历数组生成树状展开列表(其实不知道是不是这样表述)的tree组件，花了我不少的时间和精力，看来自己的实战能力确实是不够，不过后来还是做出来了<a id="more"></a>，效果不敢说如何，直接上图<br>&gt;<img src="../../../../img/7/1/效果.JPG" alt="avatar"><br>&gt;<br>  &emsp;&emsp;这个组件的开发环境为windows10 + webStorm2017 + chrome67 + webpack + babel，使用ES6和原生JS开发，未做浏览器兼容。能够实现遍历多重数组并把数组的title属性转换为li标签的内容文本，把数组的id属性转换为li标签的id属性，具有展开和折叠的动画效果，鼠标移入移出时背景色改变的动画效果，以及双击列表打印当前列表信息{title:”….”,id:”…”}等。这里直接上组件的代码，代码中已有完整注释，组件中使用得比较多的技巧有递归遍历、事件代理、三元运算，<a href="https://github.com/1206497655/tree" target="_blank" rel="noopener">点击这里</a>查看完整项目。<br><pre><code>function Tree(obj) {    const valueArr = Object.values(obj);    this.baseNode = valueArr[0];    this.treeData = valueArr[1];    this.dblclick = valueArr[2];}&#x2F;******************************** 递归遍历数组生成树状列表方法 *********************************&#x2F;Tree.prototype.initArrayTree = function(data){        let tree = &#39;&lt;ul class=&quot;ulTree&quot; id=&quot;tree-container&quot;&gt;&#39;;            for (const i in data) {                if(data.hasOwnProperty(i)){                    tree += `&lt;li id=${data[i].id} class=&quot;liTree&quot; &gt;${data[i].title}`;                    if (data[i].children) {                        tree += this.initArrayTree(data[i].children);                    }                    tree += `&lt;&#x2F;li&gt;`;                }            }        tree += &#39;&lt;&#x2F;ul&gt;&#39;;        return tree};&#x2F;********************************** * 递归获取数组内元素的总长度方法 * **********************************&#x2F;Tree.prototype.getArrayLength = function (data){    let arrLength = data.length;    for (const i in data) {        if(data.hasOwnProperty(i)){            if (data[i].children) {                arrLength += this.getArrayLength(data[i].children);            }        }    }    return arrLength};&#x2F;************************************************************* * 递归获取元素的所有后代元素，转换为普通数组，此方法暂未用到* *************************************************************&#x2F;Tree.prototype.getChildNode = function(node){    &#x2F;** 先找到子结点 **&#x2F;    let allLiNodes = [];    let nodeList = node.childNodes;    &#x2F;** 把NodeList对象转换为Array对象 **&#x2F;    for(let i=0, len = nodeList.length; i &lt; len; i++){        allLiNodes.push(nodeList[i]);    }    for(let i = 0;i &lt; nodeList.length;i++){        &#x2F;**************************************************************************         * childNode获取到到的节点包含了各种类型的节点                            *         * 但是我们只需要元素节点  通过nodeType去判断当前的这个节点是不是元素节点 *         * ************************************************************************&#x2F;        if(nodeList[i].nodeType === 1){            allLiNodes = allLiNodes.concat(this.getChildNode(nodeList[i]));        }    }    return allLiNodes;};&#x2F;************************** * 可操作树状列表生成方法 * **************************&#x2F;Tree.prototype.createTree = function () {    const data = this.treeData;    const node = this.baseNode;    const click = this.dblclick;    &#x2F;** 消除单击双击冲突用到的定时器 **&#x2F;    let TimeFn = null;    &#x2F;** 获取数组元素总个数，设置maxHeight值时会用到 **&#x2F;    const dataLength = this.getArrayLength(data);    &#x2F;** 获取树状列表 **&#x2F;    const treeBody=  this.initArrayTree(data);    &#x2F;** 使用DIV包裹起来 **&#x2F;    node.innerHTML = `&lt;div style=&quot;width: 180px; border: 1px solid black; height: auto&quot;&gt;${treeBody}&lt;&#x2F;div&gt;`;    &#x2F;** 通过class类添加通用样式样式 **&#x2F;    document.styleSheets[0].addRule(&#39;.ulTree&#39;, &#39;background-color: white;margin: 0;&#39;);    document.styleSheets[0].addRule(&#39;.liTree&#39;, &#39;list-style-type: none;height:30px;line-height:30px;transition: all .3s ease 0s;&#39;);    document.styleSheets[0].addRule(&#39;.arrow&#39;, &#39;border:5px solid transparent; border-left:5px solid #000;margin-left:10px;overflow:hidden;height:0;width:0;display:inline-block;&#39;);    document.styleSheets[0].addRule(&#39;.arrow-expend&#39;, &#39;border:5px solid transparent; border-top:5px solid #000;margin-left:10px;overflow:hidden;height:0;width:0;display:inline-block;&#39;);    &#x2F;** 循环添加组件中ul的样式 **&#x2F;    const ul = document.getElementsByClassName(&#39;ulTree&#39;);    for (let i=0;i&lt;ul.length;i++){        ul[i].style.cssText = i &gt; 0 ? &#39;padding-left: 20px;&#39;: &#39;&#39;    }    &#x2F;** 箭头图标 **&#x2F;    const arrow = &#39;&lt;span class=&quot;arrow&quot;&gt;&lt;&#x2F;span&gt;&#39;;    &#x2F;** 循环添加组件中li标签的样式 **&#x2F;    const li = document.getElementsByClassName(&#39;liTree&#39;);    &#x2F;** 无法通过getElementsByClassName获得的对象动态修改className **&#x2F;    &#x2F;** 决定列表是否应该隐藏，当列表的父元素的父元素为最外层的DIV时不隐藏 **&#x2F;    for(let i=0; i&lt;li.length; i++){        li[i].style.cssText = li[i].parentNode.parentNode.nodeName === &#39;DIV&#39;? &#39;&#39; : &#39;max-height:0;overflow:hidden&#39;;        console.log(li[i].className);        &#x2F;** 当列表元素可展开时添加箭头图标 **&#x2F;        li[i].childNodes.length &gt; 1 ?            li[i].innerHTML = arrow + li[i].innerHTML:            li[i].style.textIndent = &#39;20px&#39;;    }    &#x2F;*********************************************     *  监听li元素绑定鼠标移入事件，改变背景颜色 *     *********************************************&#x2F;    node.addEventListener(&#39;mouseover&#39;,function (e) {        const target=e.target;        if(target.nodeName === &quot;LI&quot;){            e.target.style.backgroundColor = &#39;#4D7FFF&#39;;        }    });    &#x2F;********************************************     * 监听li元素绑定鼠标移出事件，改变背景颜色 *     ********************************************&#x2F;    node.addEventListener(&#39;mouseout&#39;,function (e) {        const target=e.target;        if(target.nodeName === &quot;LI&quot;){            e.target.style.backgroundColor = &#39;#ffffff&#39;;        }    });    &#x2F;*****************************     *  处理树状列表的展开与隐藏 *     *****************************&#x2F;    node.addEventListener(&#39;click&#39;, function (e) {        &#x2F;** 每次点击清理定时器，消除与双击的冲突 **&#x2F;        clearTimeout(TimeFn);        &#x2F;** 200ms内鼠标不点击第二次时执行function **&#x2F;        TimeFn = setTimeout(function(){            const target = e.target;            &#x2F;** 保证仅点击的元素为li时才生效操作 **&#x2F;            if(target.nodeName === &#39;LI&#39;){                &#x2F;** 保证仅点击的元素含有span子元素时才生效操作，改变箭头图标 **&#x2F;                if(target.childNodes[0].nodeName === &#39;SPAN&#39;){                    const _temp = target.childNodes[0];                    _temp.className = _temp.className === &#39;arrow&#39; ? &#39;arrow-expend&#39; : &#39;arrow&#39;;                }                &#x2F;*****************************************************************************                 * 列表的隐藏与展开以及动画，展开&#x2F;隐藏动画的原理是通过css过渡transition实现的，  *                 * 动态设定元素的maxHeight时实现过渡效果，当使用height:auto或max_height:auto *                 *  将无法实现动画，因为浏览器无法从auto值进行过渡                           *                 *****************************************************************************&#x2F;                &#x2F;** 不含有子元素时，不进行操作 **&#x2F;                if (target.children.length === 0) {                    return false                } else {                    const temp_node = target.childNodes[2];                    target.style.height = &#39;auto&#39;;                    for (let i = 0; i&lt;temp_node.childNodes.length;i++){                        const temp_style = temp_node.childNodes[i].style;                        temp_style.maxHeight =                            temp_style.maxHeight === &#39;0px&#39; ?                                `${30*(temp_node.childNodes.length + dataLength)}px`:                                &#39;0px&#39;;                    }                }            }        },200);    });    &#x2F;****************************     * 双击打印当前元素内容和id *     ****************************&#x2F;    node.addEventListener(&#39;dblclick&#39;,function (e) {        clearTimeout(TimeFn);        const target = e.target;        &#x2F;** 保证仅点击的元素为li时才生效操作 **&#x2F;        if(target.nodeName === &#39;LI&#39;){            &#x2F;** 打印点击元素的内容和ID。当前元素存在两种情况，有span节点和无span节点，             * 有span节点时文本节点位于当前元素子节点的第二位，无span节点时则位于第一位 **&#x2F;            const data =  target.childNodes[0].nodeName === &#39;SPAN&#39; ?                `{title:${target.childNodes[1].textContent},id:${target.id}}`:                `{title:${target.childNodes[0].textContent},id:${target.id}}`;            click(&#39;dblclick&#39;, data);        }    });};export default Tree</code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> tree组件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS学习笔记--原型和原型继承</title>
      <link href="/2018/06/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;相信许多人和我一样弄不清楚原型的概念，原型究竟是个什么东西？现在结合笔者所学的知识以及笔记，谈谈笔者对原型的理解。<a id="more"></a><br><br> &emsp;&emsp;在js中原型主要分为prototype(显式原型)、_proto_(隐式原型)。_proto_是每一个对象都具有的属性，而prototype是函数对象Function才具有的属性。他们之间具有一个直接的指向关系：_proto_指向构造函数的prototype，意思就是构造函数Function.prototype的所有属性和方法都可以让_proto_\查询和使用。当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_(即它的构造函数的Function.prototype中寻找)。<br><br> &emsp;&emsp;下面举个例子</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//构造函数</span><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//给Foo函数的原型添加一个alerName方法</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>alertName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建示例</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span>printName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//测试</span>f<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">alertName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>&emsp;&emsp;在上述例子中，printName方法属于f对象本身的方法而不是构造函数Foo的方法，所以调用f.printName方法时，控制台输出</p><p><div align="center"><img src="/img/6/12/consoleLog.JPG"></div> <br><br>但是当调用f.alertName方法时，浏览器同样弹出了警告框</p><p><div align="center"><img src="/img/6/12/alert.JPG"></div> <br><br>这是为什么呢？这就是笔者所说的，_proto_指向问题，当调用对象自身没有的属性和方法时，js解释器会根据当前对象的_proto_指向的构造函数Foo.prototype中去寻找有无该属性或方法，如果有便返回执行，如果没有便报undefined错误。而这个其实就是我们常说的原型继承。<br>&emsp;&emsp;有趣的是，Foo.prototype其实也是一个普通对象(js万物皆对象)，那么它必然也存在有_proto_和prototype以及它们之间的指向问题，Foo.prototype_proto_究竟指向谁？这个问题留给大家思考。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> _proto_ </tag>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对于网页相关工作的一些个人看法</title>
      <link href="/2018/06/12/%E5%AF%B9%E4%BA%8E%E7%BD%91%E9%A1%B5%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/"/>
      <url>/2018/06/12/%E5%AF%B9%E4%BA%8E%E7%BD%91%E9%A1%B5%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p></p><h3>前言</h3><br>&emsp; &emsp;前些天我所在的团队回来了几个毕了业的大师兄，大家聚在一起聊天交流经验时被想从事网页前端工作的几个小师妹问了一些前端方面的问题以及发展情况，交流过后觉得应该写出来，便有了以下的个人看法，希望有误的地方能多多包涵。<a id="more"></a><br><p></p><p></p><h3>正文</h3><br>&emsp; &emsp;听说有师妹想发展网页方面的工作，我大概讲一下这方面吧。做成一个动态网页大概分三个工作：网页设计，前端开发，后端开发,不过在数年以前并不做这样的区分，基本都是由一个人完成，随着前端多样性的发展才逐渐形成现在的局面，但依然有公司要求一个人完成网页所有的开发情况，这种叫全栈开发，开发人员也叫全栈工程师。网页设计偏向设计类，主要负责网页界面设计，美工，动画，交互，业务逻辑等功能的设计等等。而前端的工作就是用代码把这个界面实现出来，要求是基本跟网页设计师设计的保持一致。后端开发负责开发后台系统，通俗的说就是数据库与网页的联动，接收网页传来的数据或者给网页发送数据。网页设计需要掌握PS、FL、FW等设计相关的软件，还要精通前端的代码，HTML、CSS。前端开发除了需要精通上面两种基础之外，还需要精通JavaScrip以及一些基于JS的开发框架，例如jQuery，Vue.js，Angular.js，React.js等，他们与JS的关系大概是C++、C#之于C语言一样，C++、C#是C语言的加强、扩展之后的版本，不同的是C语言是面向过程语言，C++、C#是面向对象语言，而JS与它的其它版本都是面向对象语言。因为我搞的前端这块，所以讲的篇幅较大，我等会另起段落。后端开发又称为后台开发，主要与数据库、服务器打交道。一个网页如果没有后台数据交换，那它就是静态网页，如果有，那它就是动态的。拿我们学校官网做例子，它是动态的，因为它有数据后台，就是那个土豆服务器，存有一个包含我们学生所有信息的数据库。我们登陆官网的时候，需要提交我们的学号和对应的密码，点击提交的时候，这些数据就会传递到服务器的后台处理系统去，这时系统会逐一在数据库中寻找有没有这个对象，密码正不正确，正确的话返回一个代表正确并允许登陆的参数至前端网页，网页根据这个参数作出界面调整，显示登录后的界面，不正确的话则显示密码出错或者密码不正确的界面。这个大动作主要包含四个小动作，传递参数、核查、返回参数、作出界面调整，前三个主要由后台开发，属于后台的工作，最后一个则是前端的工作，但他们又不是绝对独立的，后台和前端需要相互配合才能实现，例如传递的参数应该用什么格式，JSON还是其它，接口应该怎样写等等，都需要合作，相对于单片机硬件和软件的合作开发一样。后端开发需要掌握PHP、JAVA或者其它可以用来写后台的语言，还需要掌握数据库语言，例如MySql，还需要对前端的语言有所了解，方便与前端对接口。<br><br>&emsp; &emsp;下面讲讲前端。前端可以说是近三年来比较热门的职业了，市场需求量比较高,整体工资也是可观的，大概跟嵌入式开发并肩吧，但总的来说还是的看自己的本事吧，人家也不是什么人都要。前端的学习，前面说到，学习前端的基础语言HTML，CSS，JS，这是必须的，学习顺序自然是HTML-&gt;CSS-&gt;JS，通常使用的软件是WebStorm、sublime text、Atom。HTML语言有很多版本，最常用的应该是HTML5（简称H5）和DHTML，其它版本的不多描述，有兴趣的可以自己看一下。HTML语言称为超文本标记语言，属于网页三层中的结构层，它负责确定网页的内容，搭建网页的基本结构，确定标题、文本、图片的层次关系等，CSS称为层叠样式层，属于三层中的表示层，通常用来改变网页的布局、外观等，例如文本的背景颜色、输入框的边框粗细、标题文字的大小、图片的具体位置等等。JS则是行为层，负责网页的动态表现（也有用CSS实现的），人机交互等行为，例如文本框移动、点击图片自动放大、点击提交按钮提交数据等，JS出现的目的是使得人和网页的交互变得更舒服，更方便快捷。打个比方，搭建一个静态网页，就像盖房子一样。用HTML语言来去定房子的大小、客厅的位置房间卫生间的位置，然后搭建地基、砌砖，使其稳定，这是结构层。然后用CSS语言来装修，扇灰贴瓷砖铺地板等等，使其更美观布局更合理，这是表示层，然后用JS语言添加水电、灯、门窗、家电等一些实用、娱乐功能，增加交互体验，这是行为层。值得一提的是，三种层次的代码需要分离，尽量不要写在一起，浏览器的内核决定三种语言是可以写在一起的，只要使用正确的HTML元素标识出来，但这种做法并不提倡。因为这样显得代码混乱，维护起来的成本会增加，所以一般采用三层分离，即单独的写成三个文件，然后使用类似函数调用的方式调用。分离的效果要做到即使去掉表示层和行为层，文档的内容也依然可以访问，因为“内容才是一切”。而且网页的行为层 (JS) 与其结构 (HTML) 是彼此互不干扰的，不能混杂在一起。还要给行为层“预留退路”，要考虑到如果你的用户禁用了 Javascript 会怎样？是不是网页还可以正常运作。<br><br>&emsp; &emsp;说这些可能有点复杂，不过说都说了我就不删了，以后在学习的时候，再回来看看你就明白了。学习JS，需要拥有面向对象编程的思想，不了解的问问那些师兄或者百度百度吧，不然我写的太长了哈哈。然后是响应式设计和自适应式设计的思想，网页的大小是自己设定的，元素的布局也是确定的，有时候一个网页会在不同的场所被打开，或者是手机上或者是PAD上或者是电脑上，能浏览网页的终端有大有小，如果你的网页设计这针对一种终端设计，例如15.6英寸的笔记本电脑，使用的固定像素大小的元素，那这个网页在其它终端，例如4.7英寸的iPone 6S，它显示的可能就不全面甚至变形，因为笔记本的横向像素有1368个，而iPhone 6S的的横向像素只有750个，所以可能会出现页面显示不完整的情况。这时候有两种解决办法，使用自适应设计和响应式设计。自适应设计的元素大小不再固定，而是使用百分比来替代，这样无论在什么设备上，页面都会根据屏幕大小来重新计算、渲染元素的大小，使得页面能完整显示。但是这样的弊端是，无论在多大多小的屏幕都采用百分比的计算方式，容易导致出现元素过大或者过小的情况，造成视觉上的怪异。响应式设计则完美的解决了这个问题，直接根据屏幕的大小来设定不一样的界面，通过css媒体查询针对不同的屏幕尺寸区间设定不同的规则等等。<br><br>&emsp; &emsp;还有浏览器的兼容，听说大多开发前端的都死在了浏览器兼容这块，因为市面上的浏览器实在是太多了，虽然内核也就来来去去的那几个，Trident（微软IE）、Webkit(谷歌Chrome、苹果Safari)、Gecko(火狐FireFox)、Presto(Opera)，但是因为部分内核开源的缘故，出现了各式各样的浏览器，针对国内，就有被视为业界毒瘤的360浏览器、UC浏览器、搜狗浏览器等。而我的建议是，首先用谷歌浏览器和火狐浏览器练习开发和兼容，因为这是世界上占用率最高以及内核被使用率最高的两款浏览器。感觉说了些复杂的东西，这篇文章说不定以后你们看回来还有用。<br><br>&emsp; &emsp;一时半会是说不完的，任何一个方面都可以说很久，前端的魅力就在于它发展的飞快，JS框架层出不穷，新知识也不断增加。前端的学习，首先掌握HTML，CSS，这两者都是比较简单的，在这时候学习自适应设计和响应式设计，然后学习JS，到了中期学习jQuery或者zepto，es6语法，基础打扎实了，发展框架，学习Vue.js，Angular.js、React.js等,至少熟练掌握其中一个，学习模板开发，学习Less、Sass等CSS的加强版，同时了解一下什么是MVC、MVVM设计模式。前端，基础还是容易学的，但是深入难，其实我也只是个菜鸟而已。最后，学习的话一定要多做开发，动手实操，自己构思一个项目出来并实现，例如播放器什么的。写纸上都是假的，写进脑子才有用。然后推荐一个学习网站，慕课网。想必不用我说大家也知道它的厉害之处了哈哈。然后给大家一个简单的例子看看，因为时间比较匆忙我没写JS层，先感受一下H5和CSS吧。直接看后缀名来判断文件类型。双击直接打开index.html文件，出现排版乱的话就用chrome打开吧。然后尝试删除CSS文件夹看看是什么情况。哇，为什么我写论文没这么能吹。 <p></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网页前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的个人博客- -诞生</title>
      <link href="/2018/06/10/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%AF%9E%E7%94%9F/"/>
      <url>/2018/06/10/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%AF%9E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;嗨！大家好，和大家打个招呼！我是Leno，我是一名普通本科毕业生，写这篇博客为止我还没有工作，希望从事web前端开发。<a id="more"></a>这个博客是借助GitHug + Hexo实现的静态博客。网上有非常棒的教程<a href="https://www.jianshu.com/p/863f3f2d1733" target="_blank" rel="noopener">点击这里</a>，不记得从什么时候开始笔者就希望能拥有一个属于自己开发的博客，虽然现在还不够能力完全由自己开发，只能借助第三方方案实现，但是我相信以后总会有的。<br><br>&emsp;&emsp;笔者希望使用这个博客来分享一些在我的学习和工作的经验，或者是生活中遇到的烦恼，或者一些开心的事情，希望能记录自己点滴的同时也给大家带来一点小小的帮助。博客不定时更新，请大家多多关照(:</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
