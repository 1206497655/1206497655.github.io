<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SVG入门</title>
      <link href="/2019/08/10/SVG%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/10/SVG%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SVG入门"><a href="#SVG入门" class="headerlink" title="SVG入门"></a>SVG入门</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li>本章主要介绍一下SVG的技术背景，介绍SVG的使用方法、基本图形以及基本编程接口。</li></ul><h4 id="1-1-SVG"><a href="#1-1-SVG" class="headerlink" title="1.1 SVG"></a>1.1 SVG</h4><ul><li><p>SVG是一个十分庞大的标准规范，SVG1.0推出于1999年，自2003年成为W3C推荐标准，目前最新版为SGV1.1，于2011年成为推荐标准，完整的SVG1.2本来是下一个标准版本，但它又被SVG2.0取代。SVG2.0正在制定当中，它采用了类似CSS3的制定方法，通过若干松散耦合的组件形成一套标准。SVG是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形。</p></li><li><p>W3C标准（1.1）（<a href="http://www.w3.org/TR/SVG11" target="_blank" rel="noopener">http://www.w3.org/TR/SVG11</a>)</p></li><li><p>浏览器支持情况（<a href="http://caniusr.com/#cats=SVG" target="_blank" rel="noopener">http://caniusr.com/#cats=SVG</a>)</p><p>IE 9+</p><p>Chrome 33.0+</p><p>Firefox 28.0+</p><p>Safari 7.0+</p></li></ul><h4 id="1-2-位图与矢量图形"><a href="#1-2-位图与矢量图形" class="headerlink" title="1.2 位图与矢量图形"></a>1.2 位图与矢量图形</h4><p>位图（BMP、PNG、JPG等），基于颜色的描述。位图亦称为点阵图像或绘制图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。</p><p>矢量图（SVG、AI等），基于数学描述。矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。例如一幅花的矢量图形实际上是由线段形成外框轮廓，由外框的颜色以及外框所封闭的颜色决定花显示出的颜色。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真，缺点就是色彩的层次不够丰富，与直接记录色值的位图有较大的差距。</p><p><img src="../../../../img/2019/08/10/1-1 矢量图和位图.png" alt=""></p><h4 id="1-3-简单示例"><a href="#1-3-简单示例" class="headerlink" title="1.3 简单示例"></a>1.3 简单示例</h4><p>代码</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span>     <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--脸--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>90<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#fff000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--眼睛--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>70<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>130<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>65<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>75<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>125<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>75<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--嘴巴--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span> <span class="token attr-name">d</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>M 50 140 A 60 60 0 0 0 150 140<span class="token punctuation">"</span></span>         <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white<span class="token punctuation">"</span></span> <span class="token attr-name">stroke-width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>效果</p><svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><circle cx="100" cy="100" r="90" fill="#fff000"/><circle cx="70" cy="80" r="20" fill="white"/><circle cx="130" cy="80" r="20" fill="white"/><circle cx="80" cy="80" r="10" fill="black"/><circle cx="120" cy="80" r="10" fill="black"/><path d="M 50 140 A 60 60 0 0 0 150 140" stroke="white" stroke-width="3" fill="none"/></svg><h4 id="1-4-使用方式"><a href="#1-4-使用方式" class="headerlink" title="1.4 使用方式"></a>1.4 使用方式</h4><p>浏览器直接打开.svg文件</p><p>在HTML中使用 &lt;img&gt; 标签src引用.svg文件</p><p>直接在HTML中使用SVG（像编写写H5标签那样）</p><p>作为CSS背景（background-imge)</p><h3 id="2-SVG的图形和属性"><a href="#2-SVG的图形和属性" class="headerlink" title="2. SVG的图形和属性"></a>2. SVG的图形和属性</h3><ul><li><p>基本图形   &lt;rect&gt;、&lt;circle&gt;、&lt;ellipse&gt;、&lt;line&gt;、&lt;polyline&gt;、&lt;polygon&gt;   </p></li><li><p>基本属性   fill、stroke、stroke-width、transform</p></li></ul><h4 id="2-1-lt-rect-gt-矩形"><a href="#2-1-lt-rect-gt-矩形" class="headerlink" title="2.1 &lt;rect&gt; 矩形"></a>2.1 &lt;rect&gt; 矩形</h4><ul><li><p>x 表示矩形左上角距离原点的x值。</p></li><li><p>y 表示矩形左上角距离原点的y值。</p></li><li><p>width 矩形的宽。</p></li><li><p>height 矩形的高。</p></li><li><p>rx 定义x轴的圆角半径尺寸。</p></li><li><p>ry 定义y轴的圆角半径尺寸。</p></li><li><p>rx、ry只存在某一项时，另一项的值将于该项相等。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rect</span>           <span class="token attr-name">x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>           <span class="token attr-name">y</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>           <span class="token attr-name">rx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span>           <span class="token attr-name">ry</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span>           <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span>           <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span>           <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span>           <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rect</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-2-lt-circle-gt-圆"><a href="#2-2-lt-circle-gt-圆" class="headerlink" title="2.2 &lt;circle&gt; 圆"></a>2.2 &lt;circle&gt; 圆</h4><ul><li><p>cx 表示圆心到原点的x值。</p></li><li><p>cy 表示圆心到原点的y值。</p></li><li><p>r 表示圆的半径。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span>             <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>250<span class="token punctuation">"</span></span>             <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span>             <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span>             <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span>             <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>circle</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-3-lt-ellipse-gt-椭圆"><a href="#2-3-lt-ellipse-gt-椭圆" class="headerlink" title="2.3 &lt;ellipse&gt; 椭圆"></a>2.3 &lt;ellipse&gt; 椭圆</h4><ul><li><p>x 表示矩形左上角距离原点的x值。</p></li><li><p>y 表示矩形左上角距离原点的y值。</p></li><li><p>rx 定义x轴的圆角半径尺寸。</p></li><li><p>ry 定义y轴的圆角半径尺寸。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ellipse</span>              <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span>              <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span>              <span class="token attr-name">rx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>70<span class="token punctuation">"</span></span>              <span class="token attr-name">ry</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span>              <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span>              <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ellipse</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-4-lt-line-gt-直线"><a href="#2-4-lt-line-gt-直线" class="headerlink" title="2.4 &lt;line&gt; 直线"></a>2.4 &lt;line&gt; 直线</h4><ul><li><p>x1 直线开始的点的x值。</p></li><li><p>y1 直线开始的点的y值。</p></li><li><p>x2 直线结束的点的x值。</p></li><li><p>y2 直线结束的点的y值。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>line</span>           <span class="token attr-name">x1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>           <span class="token attr-name">y1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>120<span class="token punctuation">"</span></span>           <span class="token attr-name">x2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>160<span class="token punctuation">"</span></span>           <span class="token attr-name">y2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>220<span class="token punctuation">"</span></span>           <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>line</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-5-lt-polyline-gt-折线"><a href="#2-5-lt-polyline-gt-折线" class="headerlink" title="2.5 &lt;polyline&gt; 折线"></a>2.5 &lt;polyline&gt; 折线</h4><ul><li><p>points 折线转折点的点集。如points=”x1 y1 x2 y2 x3 y3”</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>polyline</span>               <span class="token attr-name">points</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>250 120                       300 220                      200 220<span class="token punctuation">"</span></span>              <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span>              <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>polyline</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-6-lt-polygon-gt-多边形"><a href="#2-6-lt-polygon-gt-多边形" class="headerlink" title="2.6 &lt;polygon&gt; 多边形"></a>2.6 &lt;polygon&gt; 多边形</h4><ul><li><p>points 多边形的角所处位置的集合。如points=”x1 y1 x2 y2 x3 y3”</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>polygon</span>              <span class="token attr-name">points</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>250 120                      300 220                     200 220<span class="token punctuation">"</span></span>             <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span>             <span class="token attr-name">stroke-width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span>             <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yellow<span class="token punctuation">"</span></span>             <span class="token attr-name">transform</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>translate(150 0)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>polygon</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-7-填充、描边和变换"><a href="#2-7-填充、描边和变换" class="headerlink" title="2.7 填充、描边和变换"></a>2.7 填充、描边和变换</h4><ul><li>fill 填充的颜色 fill=”#ffffff”</li><li>stroke 描边的颜色 stroke =”#000000”</li><li>stroke-width 描边的粗细 stroke-width=”5”</li><li>transform 表示图形坐标与父系坐标变换的值 transform=”translate(150 0)”</li></ul><h3 id="3-基本操作API"><a href="#3-基本操作API" class="headerlink" title="3. 基本操作API"></a>3. 基本操作API</h3><ul><li><p>SVG支持使用ECMAScript对其进行操作，包括动态创建、动态修改属性等。</p></li><li><p>创建图形：document.createElementNS(ns,  tagName) 。SVG元素拥有自己的命名空间，不能使用document.createElement(tagName)创建。</p></li><li>添加图形：element.appendChild(childElement) </li><li>设置属性：element.setAttribute(name,  value) </li><li>获取属性：elememt.getAttribute(name)</li></ul><h3 id="4-实践例子"><a href="#4-实践例子" class="headerlink" title="4.实践例子"></a>4.实践例子</h3><p>下面的代码使用js动态地在id为SVGContainer的div中添加了一个三角形，并设置了它的属性。基本上跟操作html元素没太大区别。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector"><span class="token id">#SVGContainer</span> </span><span class="token punctuation">{</span>      <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">;</span>      <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SVGContainer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// SVG元素的命名空间</span>    <span class="token keyword">const</span> SVG_NS <span class="token operator">=</span> <span class="token string">"http://www.w3.org/2000/svg"</span>    <span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'SVGContainer'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> SVG <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span>SVG_NS<span class="token punctuation">,</span> <span class="token string">'svg'</span><span class="token punctuation">)</span>    div<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>SVG<span class="token punctuation">)</span>    SVG<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span> <span class="token string">'200'</span><span class="token punctuation">)</span>    SVG<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">,</span> <span class="token string">'200'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> polygon <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span>SVG_NS<span class="token punctuation">,</span> <span class="token string">'polygon'</span><span class="token punctuation">)</span>    polygon<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'points'</span><span class="token punctuation">,</span> <span class="token string">'150 60 200 160 100 160'</span><span class="token punctuation">)</span>    polygon<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'stroke'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">)</span>    polygon<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'stroke-width'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">)</span>    polygon<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'fill'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">)</span>    polygon<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'transform'</span><span class="token punctuation">,</span> <span class="token string">'translate(-50,0)'</span><span class="token punctuation">)</span>    SVG<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>polygon<span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><svg height="200" width="200"><polygon points="150 60 200 160 100 160" stroke="red" stroke-width="5" fill="yellow" transform="translate(-50,0)"/></svg><h3 id="5-本章总结"><a href="#5-本章总结" class="headerlink" title="5.本章总结"></a>5.本章总结</h3><p>本章主要学习了SVG的基本图形元素&lt;rect&gt;、&lt;circle&gt;、&lt;ellipse&gt;、&lt;line&gt;、&lt;polyline&gt;、&lt;polygon&gt;，基本属性fill、stroke、stroke-width、transform和基本四个API。  除此之外还有许多其它各色各样的元素、属性和API，请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="noopener">MDN</a>。</p><p>下一章将学习SVG中的坐标系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SVG </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Object.freeze冻结对象的深层理解</title>
      <link href="/2019/08/03/Object-freeze%E5%86%BB%E7%BB%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%B1%82%E7%90%86%E8%A7%A3/"/>
      <url>/2019/08/03/Object-freeze%E5%86%BB%E7%BB%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%B1%82%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Object.freeze()冻结对象的深层理解。Vue介绍响应式系统的文档中提到，使用Object.freeze()方法冻结对象，可以使得该对象无法进行更新响应，对系统的性能优化有一定的帮助。在MDN中对Object.freeze()的介绍如下：<br>可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。<br>具体是怎么做的呢？首先我们需要知道ECMAScript有两种属性：数据属性和可访问器属性（为了表示特性是内部值，规范（ECMA-262）就把它们放到了两对方括号里了，例如 [[Enumerable]]）。<br>数据属性<br>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：<br>  [[Configurable]] : 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。<br>  [[Enumerable]] : 表示能否通过 for-in 循环返回属性。<br>  [[Writable]] : 表示能否修改属性的值。<br>  [[Value]] : 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值时，把新值保存在这个位置。默认值是 undefined。<br>像这样（var obj = new Object(); obj.name = “percy”;）或者像通过对象字面量（var obj = {name: “percy”};）直接在对象上定义的属性，它们的 [[Configurable]]、[[Enumerable]] 和 [[Writable]] 特性默认都被设置为 true，而 [[Value]] 特性被设置为指定的值。<br>可以使用Object.getOwnPropertyDescriptor(object, ‘property’)来查看。例如：<br>  <div align="center"><img src="../../../../img/2019/08/03/1.png"></div> <br><br>访问器属性<br>访问器属性不包含数据值，他们包含一对getter和setter函数（这也是实现vue1.x-vue2.x响应式的关键），不过这两个函数不是必须的。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新的值，这个函数负责决定如何处理数据。访问器有如下4个特性：<br>  [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。<br>  [[Enumerable]]：表示能否通过 for-in 循环返回属性。<br>  [[Get]]：在读取属性时调用的函数。默认值为 undefined。<br>  [[Set]]：在写入属性时调用的函数。默认值为 undefined。<br>当调用了Object.freeze()方法冻结对象时，就像MDN描述的那样，冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。也就是数据属性的[[Configurable]]、[[Writable]]特性都被设置为false。就像上述的例子被冻结后：<br>  <div align="center"><img src="../../../../img/2019/08/03/2.png"></div> <br><br>注意，Object.freeze()是一个不可逆的过程，[[Configurable]]也包含了对特性的描述，设置为false后将不能修改属性的任何特性，包[[Configurable]]自身。所以使用时应当确认该数据是否会被再次修改。<br>总结，对象被冻结后是无法做任何修改的，所以vue无法设置这些对象的Setter和Getter函数或其它实现响应式需要的特性，也就实现vue系统的非响应式的对象。不过在确认对象被冻结后，这个设置过程会被直接忽略。<br>以上是我个人的见解，有误的地方请指教~~最后祝大家周末愉快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript高级程序设计之垃圾收集机制</title>
      <link href="/2019/07/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近在读《JavaScript高级程序设计(第三版)》，我在大学时有幸接触过一下这本书，但是当时对JS并不是很了解，书中内容大多晦涩难懂，没有工作经<br>验的人几乎很难读懂，现在重新阅读一遍感觉打开了新世界的大门（虽然还没读完）。对于工作了一段时间的我来说，这本书的作用恰到好处，解开了我在工作中遇到的一些谜题以及更加深入理解JS的运行机制。现在挑选部分我个人认为比较有趣的知识分享给大家。<br>1.垃圾收集机制：<br>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。以前学习的C/C++语言中，程序的内存是需要手动跟踪的，变量使用完毕后若果不手动清空便会残留在内存中，容易造成内存泄漏问题。在JS中几乎不用担心这个问题（当然只是几乎），所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾回收机制原理很简单：周期性地找出不再继续使用的变量然后释放其内存。垃圾收集方式一般分为两种，标记清除和引用计数，现在普遍都是标记清除的方式，引用计数基本不见，原因在后。标记清除，最常用的垃圾收集方式。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量，也就是被标记为“进入环境”的变量，因为只要执行流进入相应的环境，就可能会用到它。而当变量离开环境时，则将其标记为“离开环境”。到了周期执行垃圾收集任务时，被标记为“离开环境”的变量将会被收集起来销毁并回收其内存。引用计数方式，其含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用此时就是1。如果同一个值又被赋予给另一个变量，则该值的引用次数加1。相反，如果引用了该值的变量引用了其它值，则该值的引用次减1，当该值的引用此时为0时，意味着该值无法再被访问，等待被周期垃圾收集器收集并释放掉。但是这种方式有一个严重的问题：循环引用。循环引用是指对象A中包含指向对象B的引用，而对象B中也包含一个指向对象A的引用。例如：<br>  <div align="center"><img src="../../../../img/2019/07/21/1.png" width="50%" height="50%"></div> <br><br>在这个例子中，objA与objB通过各自的属性进行相互引用，也就是这两个对象都被引用了2次，并且次数永远都不会是0，那么可想而知，垃圾收集器将无法回收这两个值得内存，若程序中存在大量这种情况或者多次执行该函数就会造成大量内存得不到回收引发其它问题。而标记清除方式则不会存在这个问题，因为函数运行结束时这两个值随即离开了作用域，被标记为“离开环境”。在这个问题出现后，新版的JS标准摒弃了这种方式，在现代浏览器中几乎没有。<br>即使有了这种机制，我们开发人员仍然要注意内存问题，例如在vue组件中，若是常驻组件，则该组件的内的所有数据都不会被自动回收，因为它们永远存在于父组件形成的环境中，所以此时就需要我们去关注组件内的哪些数据，在组件视觉上关闭后重新打开不会再次被使用时，及时的在关闭组件这个周期被将其清空或者直接将组件设计成关闭即destory形式以节约内存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>控制git_commit时的提交信息格式</title>
      <link href="/2019/07/06/%E6%8E%A7%E5%88%B6git-commit%E6%97%B6%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/07/06/%E6%8E%A7%E5%88%B6git-commit%E6%97%B6%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> 利用husky和commintlint插件控制git commitlint时的提交信息格式。<br>项目里虽然写明了在提交代码时需要表明提交类型，以此来表明此次提交的改动类型，是新增功能还是修改bug还是重构等，但是也有粗心大意的时候。为了杜绝这种情况，项目里就可以增加一种限制来禁止提交不规范的commit messege。安装husky，husky继承了Git下所有的钩子，允许开发者在git钩子下做想做的事情，结合commitlint就可以实现在commit前检查messege的格式，是否符合项目的要求。使用很简单：<br>安装：<br>  <div align="center"><img src="../../../../img/2019/07/06/0.png" width="50%" height="50%"></div> <br><br>  <div align="center"><img src="../../../../img/2019/07/06/1.png" width="50%" height="50%"></div> <br><br>新增文件commitlint.config.js，文件内容如下：<br>  <div align="center"><img src="../../../../img/2019/07/06/2.png" width="50%" height="50%"></div> <br><br>该文件是commitlint的配置文件，可根据项目需求参考官网配置项进行修改。<br>在package.json新增字段：<br>  <div align="center"><img src="../../../../img/2019/07/06/3.png" width="50%" height="50%"></div> <br><br>然后就可以在git的commit-msg钩子限制commit messege的格式了。默认格式为：<br>Type：（两个空格）信息  例如：Add:  新增功能</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用vue.mixin减少文件体积</title>
      <link href="/2019/06/29/%E5%88%A9%E7%94%A8vue-mixin%E5%87%8F%E5%B0%91%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF/"/>
      <url>/2019/06/29/%E5%88%A9%E7%94%A8vue-mixin%E5%87%8F%E5%B0%91%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>Vue.mixin()混入API除了分发 Vue 组件中的可复用功能，还能用来解决单个文件过大的问题。<br>当我们遇到一些逻辑实在是很复杂，需要写很多个方法才能实现的模块又无法拆分组件时，可以使用vue.mixin来解决单个文件过大的问题，把一些相关的逻辑或数据写在独自的mixin.对象内分发出去，减少文件体积从而提升代码可读性。一个混入对象可以包含任意组件选项，如data、created、method等，所有混入对象的选项将被“混合”进入该组件本身的选项。例如：<br>  <div align="center"><img src="../../../../img/2019/06/29/1.png" width="50%" height="50%"></div> <br><br>需要注意的是：在使用模板创建的vue中使用时，mixins选项需写在data选项前。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js浮点运算陷阱</title>
      <link href="/2019/06/01/js%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E9%99%B7%E9%98%B1/"/>
      <url>/2019/06/01/js%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p>  开发模型管理引擎时遇到传说中的浮点运算陷阱：浮点运算计算结果出现0.000000001 和 0.999999999这样的奇怪结果或误差，例如如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998等，出现这种误差的原因跟JS的储存小数的机制有关，原理比较复杂，有需要的具体可参考这篇文章<a href="https://www.cnblogs.com/sunshq/p/7682109.html。比较简单的解决办法是，使用" target="_blank" rel="noopener">https://www.cnblogs.com/sunshq/p/7682109.html。比较简单的解决办法是，使用</a> toPrecision 凑整并 parseFloat 。例如parseFloat(1.4000000000000001.toPrecision(12)) === 1.4。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用canvas元素重叠带透明度的照片的方法</title>
      <link href="/2019/05/11/%E7%94%A8canvas%E5%85%83%E7%B4%A0%E9%87%8D%E5%8F%A0%E5%B8%A6%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E7%85%A7%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/11/%E7%94%A8canvas%E5%85%83%E7%B4%A0%E9%87%8D%E5%8F%A0%E5%B8%A6%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E7%85%A7%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>用canvas元素重叠带透明度的照片的方法：<br>使用canvas重叠两张图片时，若图片带有透明度，使用canvas重叠后不会直接带有透明效果。<br>可以使用canvas. globalAlpha来解决此问题。</p><p>  <div align="center"><img src="../../../../img/2019/05/11/1.png" width="50%" height="50%"></div> <br></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记录一下elementUI的tree节点过长缺无法横向滚动的问题</title>
      <link href="/2019/04/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BelementUI%E7%9A%84tree%E8%8A%82%E7%82%B9%E8%BF%87%E9%95%BF%E7%BC%BA%E6%97%A0%E6%B3%95%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BelementUI%E7%9A%84tree%E8%8A%82%E7%82%B9%E8%BF%87%E9%95%BF%E7%BC%BA%E6%97%A0%E6%B3%95%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记录一下elementUI的tree节点过长缺无法横向滚动的问题：<br>在用el-tree做模型管理引擎左侧的模型目录树的时候发现一些UI上的问题，如果装载tree的容器宽度很小（此项目大概为10%屏幕宽度），然而节点较多文字较长时，el-tree无法正常滚动。<br>  <div align="center"><img src="../../../../img/2019/04/05/7.png" width="50%" height="50%"></div> <br></p><p>修复方法：在el-tree组件内部的最外层容器的class样式el-tree中修改样式如下：<br>  <div align="center"><img src="../../../../img/2019/04/05/8.png" width="50%" height="50%"></div> <br></p><p>亲测有效，特此记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue项目编译后部署在非网站根目录的解决方案</title>
      <link href="/2019/04/05/Vue%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E5%90%8E%E9%83%A8%E7%BD%B2%E5%9C%A8%E9%9D%9E%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/04/05/Vue%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E5%90%8E%E9%83%A8%E7%BD%B2%E5%9C%A8%E9%9D%9E%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Vue项目编译后部署在非网站根目录的解决方案。<br>背景：在公司的网站部署中，项目的项目地址一般都不是网站根目录，而是某个子目录。例如：<br>  <div align="center"><img src="../../../../img/2019/04/05/1.png" width="50%" height="50%"></div> <br></p><p>这样子就得针对子目录做些编译配置，否则在路由跳转或者访问静态资源得时候出错。<br>  <div align="center"><img src="../../../../img/2019/04/05/2.png" width="50%" height="50%"></div> <br></p><p>修改配置文件：<br>  <div align="center"><img src="../../../../img/2019/04/05/3.png" width="50%" height="50%"></div> <br></p><p>修改路由:<br>由于history模式下所有路由都是基于网站根路径的，所以在路由跳转的时候会出现这种错误情况：<br>跳转前路由：<br>  <div align="center"><img src="../../../../img/2019/04/05/4.png" width="50%" height="50%"></div> <br></p><p>跳转目的路由：<br>  <div align="center"><img src="../../../../img/2019/04/05/5.png" width="50%" height="50%"></div> <br></p><p>可以看见跳转后路由以根目录为基准进行跳转，不再以DME子目录为基准，导致路由跳转出错。<br>所以针对这个进行修改，通过location.pathname来决定路由的基准。</p><p>修改tomcat配置：<br>部署后虽然能正常访问，但是刷新后会报路由错误。在网站目录下增加文件夹WEB-INF，里面放置新文件web.xml<br>新文件内容如下：<br>  <div align="center"><img src="../../../../img/2019/04/05/6.png" width="50%" height="50%"></div> <br></p><p>最后大家假期愉快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于翻译插件的问题</title>
      <link href="/2019/03/23/%E5%85%B3%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/23/%E5%85%B3%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>关于翻译插件的一个问题：在开发临沧一张图专题目录树的时候，出项这样一个问题。写入页面的html代码</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>某某某<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><p>在实施测试的时候，却变成了如下这样</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token punctuation">></span></span>某某某<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span></code></pre><p>代码出现了不明标签，经排查，确定是浏览器翻译插件（谷歌翻译）的锅。实施在测试时开启了谷歌翻译翻页了当前页面。如果在浏览器中开启插件对当前开发页面进行了翻译，页面的结构将会被改变。即使当前页面翻译前后都是中文字体 。比如：<br>当前页面结构：<br>  <div align="center"><img src="../../../../img/2019/03/23/1.png" width="50%" height="50%"></div> <br><br>使用翻译插件之后：<br>  <div align="center"><img src="../../../../img/2019/03/23/2.png" width="50%" height="50%"></div> <br><br>可以看到span标签内的纯文本在翻译之后增加了双层的<font>标签，当然这是翻译工具的工作行为。这样带来的问题是获取span标签内的纯文本变得不再简单。解决办法是关闭插件翻译或者使用String.replace()方法对元素取出的innerHTML进行过滤处理。</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>地图打印步骤</title>
      <link href="/2019/03/15/%E5%9C%B0%E5%9B%BE%E6%89%93%E5%8D%B0%E6%AD%A5%E9%AA%A4/"/>
      <url>/2019/03/15/%E5%9C%B0%E5%9B%BE%E6%89%93%E5%8D%B0%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>地图打印步骤：<br>服务器端打印<br>执行对象是 PrintTask，打印的参数是 PrintParameters，通过设置打印模板对象 PrintTemplate，可以对图片的大小，像素，格式等进行设置。示例：在服务器端打印一个中国地图。<br>（1）     初始化PrintTask对象。<br>// printTaksUrl打印服务 async异步或同步<br>Var printTask = new esri.tasks.PrintTask(printTaksUrl, async)；<br>（2）设置打印参数，模板，布局等并进行打印操作<br>function PrintTask () {<br>    var template = new esri.tasks.PrintTemplate();<br>    template.exportOptions = {<br>        width: 850,<br>        height: 650,<br>        dpi: 96<br>    };<br>    template.format = “PDF”; // 设置输出格式<br>    template.layout = “MAP_ONLY”; // 设置排版<br>    template.preserveScale = true;<br>    var params = new esri.tasks.PrintParameters();<br>    params.map = Map;<br>    params.template = template;<br>    PrintMap.execute(params, showRender, ShowError)<br>}<br>（3）获取打印结果<br>function showPrintRes(renderer) {<br>    if(rederer != null) {<br>        window.open(renderer.url);<br>    }<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不同坐标系测量面积和距离的不同方法</title>
      <link href="/2019/03/15/%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E6%B5%8B%E9%87%8F%E9%9D%A2%E7%A7%AF%E5%92%8C%E8%B7%9D%E7%A6%BB%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/15/%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E6%B5%8B%E9%87%8F%E9%9D%A2%E7%A7%AF%E5%92%8C%E8%B7%9D%E7%A6%BB%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>不同坐标系测量面积和距离的不同方法</p><p>坐标系主要分为地理坐标系和投影坐标系，根据wkid来区分。不同的坐标系类型测量面积和距离的方法不同，首先是投影坐标系：<br>require([“esri/geometry/geometryEngine”], function(geometryEngine) {<br>    // 测量面积方法<br>    _calArea: function (geometry, areaUnit){ // geometry几何信息 areaUnit面积单位<br>        return geometryEngine.planarArea(geometry, areaUnit)<br>    }<br>    // 测量长度方法<br>    _calLength: function (geometry, lengthUnit) {<br>        return geometryEngine.planarLength(geometry, lengthUnit)<br>    }<br>});<br>再次是地理坐标系：<br>require([“esri/geometry/geodesicUtils”], function(geodesicUtils) {<br>// 测量面积方法<br>    _calArea: function (geometry, areaUnit){ // geometry几何信息 unit单位类型<br>        return geodesicUtils.geodesicAreas((geometry, areaUnit)<br>    }<br>    // 测量长度方法<br>    _calLength: function (geometry, lengthUnit) {<br>        return geodesicLengths.geodesicLengths(geometry, lengthUnit)<br>    }<br>});</p>]]></content>
      
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决arcgis地图打印无法打印PictureMarkerSymbol</title>
      <link href="/2019/03/01/%E8%A7%A3%E5%86%B3arcgis%E5%9C%B0%E5%9B%BE%E6%89%93%E5%8D%B0%E6%97%A0%E6%B3%95%E6%89%93%E5%8D%B0PictureMarkerSymbol/"/>
      <url>/2019/03/01/%E8%A7%A3%E5%86%B3arcgis%E5%9C%B0%E5%9B%BE%E6%89%93%E5%8D%B0%E6%97%A0%E6%B3%95%E6%89%93%E5%8D%B0PictureMarkerSymbol/</url>
      
        <content type="html"><![CDATA[<p>解决arcgis地图打印无法打印PictureMarkerSymbol<br>地图打印时无法打印含有PictureMarkerSymbol的图层，改用SimpleMarkerSymbol + SVG的形式可以解决。<br>（PNG/JPG可以通过在线软件转换为SVG，只要要其中的path值）代码：<br>  var path = “M96 278 c-7 -18 -27 -50 -44 -71 -17 -21 -34 -51 -37 -68 -24 -109 95 -183 177 -110 28 25 33 36 33 74 0 36 -7 54 -33 89 -18 23 -41 60 -50 80 -9 21 -20 38 -24 38 -4 0 -14 -15 -22 -32z”; // 原图片转SVG后的path<br>  this.pictureSys = new SimpleMarkerSymbol();<br>  this.pictureSys.setPath(path);<br>  this.pictureSys.setColor(new Color([255, 0, 0, 255]))<br>  this.pictureSys.setOutline(null);<br>  this.pictureSys.setSize(“32”);</p>]]></content>
      
      
      
        <tags>
            
            <tag> arcgis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用的解决跨域问题的方法之一：jsonp</title>
      <link href="/2019/02/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E4%B9%8B%E4%B8%80%EF%BC%9Ajsonp/"/>
      <url>/2019/02/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E4%B9%8B%E4%B8%80%EF%BC%9Ajsonp/</url>
      
        <content type="html"><![CDATA[<pre><code>常用的解决跨域问题的方法之一：jsonp</code></pre><p>跨域安全限制问题实际上只存在于浏览器端，服务器是不存在跨域问题的。所以代理服务器也是解决跨域问题的方式之一。但由于技术资源限制，本项目只能采用其它解决跨域的方式—-jsonp。<br>浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。如果协议，端口和主机对于两个页面是相同的，则两个页面具有相同的源，否则就是不同源的，无法进行跨域请求，除了以下一些特殊情况。<br>JS中存在一些特殊标签，它们可以不受同源策略限制去访问不同域的资源，例如\<img>标签可以随意展示不同源的图片资源，\<script>标签可以随意使用CDN引入第三方js插件等。利用这个原理，使用<script>标签来实现无其它跨域处理的情况下的跨域请求。当我们触发请求时，添加一个<script>标签，用于发起跨域请求；请求地址后面带一个callback=showData的参数；showData即是回调函数名称，传到后台，后台用于包裹数据。数据返回到前端后，就是showData(result)的形式，因为是script脚本，所以自动调用showData函数，而result就是showData的参数。至此，我们算是跨域把数据请求回来了，但是比较麻烦，需要自己写脚本发起请求，然后写个回调函数处理数据，不是很方便。更方便的方法是使用jQuery的jsonp请求方式，只需要在发起ajax请求时配置dataType为’jsonp’类型，即可自动生成一个回调函数或者以success函数作为回调函数传送给后台，然后获取数据。当然，后台也需要做专门的包裹数据处理。</p></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>element-ui隐藏滚动条组件el-scrollbar的使用</title>
      <link href="/2019/02/15/element-ui%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%BB%84%E4%BB%B6el-scrollbar%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/15/element-ui%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%BB%84%E4%BB%B6el-scrollbar%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>element-UI 隐藏滚动条组件 el-scrollbar 的使用<br>使用方式像普通的 element-UI 组件一样使用<br>接受的props有：<br>native: Boolean  // 如果为true就不显示el的bar，也就是el模拟出来的滚动条，如果为false就显示模拟的滚动条<br>wrapStyle: Object  // 外层盒子的样式<br>wrapClass: Object  // 外层盒子的class<br>viewStyle: Object  // 内层盒子的样式<br>viewClass: Object  // 内层盒子的class<br>noresize: Boolean  // 如果 container 尺寸不会变化，最好设置它可以优化性能<br>tag: {<br>        type: String,<br>        default:  ‘div’<br>}  // 设置容器的标签</p>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue动态img标签引用图片</title>
      <link href="/2019/01/25/vue%E5%8A%A8%E6%80%81img%E6%A0%87%E7%AD%BE%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87/"/>
      <url>/2019/01/25/vue%E5%8A%A8%E6%80%81img%E6%A0%87%E7%AD%BE%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>vue 绑定img标签src属性，无法读取路径的问题：<br>在vue开发中使用img的src属性绑定url变量时，经常会出现图片加载失败的问题。这是因为在变量中直接使用相对路径时，vue会把网站根路径作为根目录，而编译后的站点，图片的路径与工程路径是不一样的，webpack打包后工程中静态图片存放在public这个文件夹下，所以会出现找不到该文件的错误。</p><p>比较高质量的解决办法是使用import url from “../../assets/img/EMS.png”来导入图片路径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试代码运行时间</title>
      <link href="/2018/12/21/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
      <url>/2018/12/21/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<ol><li>测试代码运行时间：performance.now()能精确获取当前时间点（千分之一毫秒），能十分方便快捷地测试代码块运行时间。例如：<br>function(){<br> var time1 = performance.now()<br> console.log(‘666’)<br> var time2 = performance.now()<br> console.log(time2 - time1) // 单位ms<br>}</li><li>阻止浏览器的默认drag拖拽：<br>使用mousemove事件设计可移动的元素时，很容易受到darg拖拽事件的影响，解决办法就是在目标移动元素上绑定dragstart事件：function() { return false}，以此来直接阻止drag事件传递。参考<a href="https://javascript.info/mouse-drag-and-drop" target="_blank" rel="noopener">https://javascript.info/mouse-drag-and-drop</a>          </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式匹配固定头尾的字符串</title>
      <link href="/2018/12/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%9B%BA%E5%AE%9A%E5%A4%B4%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%9B%BA%E5%AE%9A%E5%A4%B4%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>正则表达式匹配固定头尾的字符串</p><p>例如要匹配以下所有数据：<br> (“FA60AFAA-C0C1-4E5A-9B62-23026F3D8EAA”:</p><p>(“6DE3FA9B-EDC9-4CF0-E053-49C8A8C029B0”:</p><p>(“9AB0D392-699C-F693-09CC-1FCC5D2E1934”:</p><p>(“FBEC781C-B552-411C-AF64-6FBA59D42F1D”:</p><p>这数据的共同点都是以<code>(&quot;</code>开头，以<code>&quot;</code>结束，</p><p>所以结构应该为：<code>\(&quot;regex&quot;</code>，其中regex待定。原本以为<code>regex = &#39;*&#39;</code>时能实现匹配，结果不能，查看资料才明白<code>&#39;*&#39;匹配前面的子表达式零次或多次。</code>，也就是说<code>*</code>前面需要一个用来匹配的表达式（现在的情况是匹配<code>&quot;</code>这个符号零次或多次）…</p><p>然后继续查找资料发现<code>\S</code>匹配所有非空白符号，使<code>regex = &#39;[\S]*&#39;的</code>时候实现了我想要的结果，成功匹配出所有类似字符串。最终正则表达式为<code>\(&quot;[\S]*&quot;</code></p><p>如果字符串中出项空白符号时，以上正则表达式将不能匹配，改为这样<code>\(&quot;[\s\S]*&quot;</code>即可。其中<code>\s</code>的意思是’匹配空白符号’</p>]]></content>
      
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>element-ui在vue中覆盖样式</title>
      <link href="/2018/12/06/element-ui%20%E5%9C%A8vue%E4%B8%AD%E8%A6%86%E7%9B%96%E6%A0%B7%E5%BC%8F/"/>
      <url>/2018/12/06/element-ui%20%E5%9C%A8vue%E4%B8%AD%E8%A6%86%E7%9B%96%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>vue主张使用scoped关键字来解决css样式的全局污染问题，这样的解决方式明显简单了许多，不过也有一些意外情况，例如想要覆盖一些第三方ui的样式（如elementUi）时，因为大部分的样式都是通过全局样式引入的，在某个页面想进行样式覆盖又存在scoped关键字时显然无法进行覆盖。解决方式有两种：</p><p>1.去掉 <code>scoped</code> 提升样式至全局。但是这样的话需要增加命名空间以解决污染问题。</p><pre class=" language-scss"><code class="language-scss"><span class="token selector">.article-page </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 你的命名空间 */</span>  <span class="token selector">.el-tag </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* element-ui 元素*/</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2.使用深度选择器。当你子组件使用了 <code>scoped</code> 但在父组件又想修改子组件的样式可以 通过 <code>&gt;&gt;&gt;</code> 来实现：</p><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;style scoped><span class="token class">.a</span> >>> <span class="token class">.b</span> </span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>&lt;/style></code></pre><p>将会编译成：</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.a</span><span class="token attribute">[data-v-f3f3eg9]</span> <span class="token class">.b</span> </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* ... */</span><span class="token punctuation">}</span></code></pre><p>注意：当使用了sass等css预处理语言时， <code>&gt;&gt;&gt;</code> 可能不会生效，此时可以使用 <code>/deep/</code> 替换，它的作用跟 <code>&gt;&gt;&gt;</code> 时一样的。</p><style scoped>.a /deep/ .b { /* ... */ }</style><p>除此之外，父级选择器应该是能够被选中的全局样式，如上的 <code>.a</code> ，它应该组件最顶层的父级容器样式，能够被全局样式判定，否则深度选择器是找不到目标样式的。假如组件的样式结构如下：</p><pre class=" language-scss"><code class="language-scss"><span class="token selector">.article-page </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 你的命名空间 */</span>  <span class="token selector">.el-tag </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* element-ui 元素*/</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>那么深度选择器应该从 <code>.a</code> 样式作为父级选择器开始，比我要改变 <code>.c</code> 样式，从以下方式改变是不行的:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span> <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scss<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.b</span> /deep/ <span class="token class">.c</span> </span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 修改失败，无法找到 .c 元素, 父级元素未知 */</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>正确的做法应该是这样的:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span> <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scss<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.a</span> /deep/ <span class="token class">.b</span> /deep/ <span class="token class">.c</span> </span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 修改成功 */</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>以上结果基于vue + elementUi测试获得，其它ui未知。欢迎纠错。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探索发现--关于compositionstart、input和compositionend事件去除拼音响应的研究</title>
      <link href="/2018/11/28/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0-%E5%85%B3%E4%BA%8Ecompositionstart%E3%80%81input%E5%92%8Ccompositionend%E4%BA%8B%E4%BB%B6%E5%8E%BB%E9%99%A4%E6%8B%BC%E9%9F%B3%E5%93%8D%E5%BA%94%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/11/28/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0-%E5%85%B3%E4%BA%8Ecompositionstart%E3%80%81input%E5%92%8Ccompositionend%E4%BA%8B%E4%BB%B6%E5%8E%BB%E9%99%A4%E6%8B%BC%E9%9F%B3%E5%93%8D%E5%BA%94%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>关于利用compositionstart、input和compositionend事件给input元素即时响应去除拼音阶段响应的发现：compositionstart事件在拼音输入阶段开始触发的事件，compositionend事件在输入拼音阶段结束后触发的事件，大部分浏览器都相同，而input事件在不同的浏览器或不同的版本的浏览器之间的顺序有所不同，部分是发生在compositionend事件之前，部分却是在compositionend事件之后，这样给input元素针对中文做即时响应时带来许多不良影响，针对此种情况可以使用keyup事件替代，因为大部分浏览器keyup事件都是在compositionend事件之后的。<a id="more"></a></p><p>测试代码大概是：</p><pre><code>var inputZh = false  &#x2F;&#x2F; 是否结束输入法获取文字标记inputNode.addEventListener(&#39;compositionstart&#39;, function () {    inputZh = false &#x2F;&#x2F; 开始输入法时置为 false    console.log(&#39;compositionstart&#39;)})oinputNode.addEventListener(&#39;compositionend&#39;, function () {    inputZh = true &#x2F;&#x2F; 结束输入法时置为true    console.log(&#39;compositionend&#39;)})inputNode.addEventListener(&#39;inputNode&#39;, function() {    console.log(&#39;input&#39;)    if (inputZh) { &#x2F;&#x2F; 按下空格键结束输入法时进行响应        &#x2F;* 要处理的代码块 *&#x2F;    }})</code></pre><p>下图是chrome 33拼音输入控制台打印结果：<br><img src="/img/11/28/chrome 33.0.1750.117.png" alt=""><br><!-- ![](E:\notes\img\chrome 33.0.1750.117.png) --></p><p>分析：chrome 33运行此段代码时，拼音输入法在按下空格键之后（即结束输入法获得文字）触发的事件顺序为: compositionend -&gt; input， 这样子就能在compositionend事件时把inputZh置为true然后再之后触发的input事件中处理响应任务。</p><p>下图时chrome 70 拼音输入控制台打印结果：</p><p><img src="/img/11/28/chrome 70.0.3538.102.png" alt=""><br><!-- ![](E:\notes\img\chrome 70.0.3538.102.png) --></p><p>分析：chrome 70的结果显然不是我们想要的。拼音输入把结束输入法的空格键也计算在输入拼音阶段，导致无法在input事件前通过compositionend事件使inputZh标志置为true，所以无法实现拼音过滤。</p><p>下图时firfox 59 拼音输入控制台打印结果：</p><p><img src="/img/11/28/fireFox 63.03.png" alt=""><br><!-- ![ ](E:\notes\img\fireFox 63.03.png) --></p><p>firefox 59与chrome 33相同。</p><p>虽然只是简单的测试了一下，但是从两大浏览器就可以得出input事件与compositionstart、compositionend顺序不一致的问题。解决这个问题的最简单的方法就是使用keyup事件替代input事件，因为大多数浏览器的keyup顺序都是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compositionstart </tag>
            
            <tag> compositionend </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决高度设置为auto时无法过渡的情况</title>
      <link href="/2018/11/28/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E4%B8%BAauto%E6%97%B6%E6%97%A0%E6%B3%95%E8%BF%87%E6%B8%A1%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2018/11/28/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BA%A6%E8%AE%BE%E7%BD%AE%E4%B8%BAauto%E6%97%B6%E6%97%A0%E6%B3%95%E8%BF%87%E6%B8%A1%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>css高度过渡(从0过渡至过渡为auto情况),transition过渡只能从一个明确的属性值过渡至另一个明确的属性值,不能从任意一个不确定值过渡至一个确定值,这样是不起作用的,例如常见的<strong>height: 0</strong>过渡至<strong>height: auto</strong>.解决办法:<br><a id="more"></a><br>    使用transform：scaleY(0)替代始值。transform: scaleY(1)替代终值。<br><pre><code>css: {  transform：scaleY(0);  transform-origin: 0% 0%;}css: {  transform: scaleY(1)}</code></pre></p><p> 注意: 未添加transform-origin: 0% 0%;的情况下默认从过度对象Y轴中点开始往上下扩张，使用后默认从Y轴顶点开始向下扩张。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 高度过渡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设置VSCode下Vue代码自动格式化</title>
      <link href="/2018/11/28/%E8%AE%BE%E7%BD%AEVSCode%E4%B8%8BVue%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2018/11/28/%E8%AE%BE%E7%BD%AEVSCode%E4%B8%8BVue%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>安装Vetur插件，打开VSCode下的setting.json，加入如下配置:<br><a id="more"></a><br><pre><code>&#x2F;&#x2F; 保存自动格式化&quot;editor.formatOnSave&quot;: true,&#x2F;&#x2F; 保存时自动fix&quot;eslint.autoFixOnSave&quot;: true,&#x2F;&#x2F; 添加 vue 支持&quot;eslint.validate&quot;: [    &quot;javascript&quot;,    &quot;javascriptreact&quot;,    {        &quot;language&quot;: &quot;vue&quot;,        &quot;autoFix&quot;: true    }],&#x2F;&#x2F; 屏蔽vetur的js格式化&quot;vetur.format.defaultFormatter.js&quot;: &quot;none&quot;&#x2F;&#x2F; 使用插件格式化 html&quot;vetur.format.defaultFormatter.html&quot;: &quot;prettyhtml&quot;</code></pre></p><p>注意：<br>    1.代码风格使用著名的prettier风格。<br>    2.在*.vue文件保存时会执行两次格式化，一次是Vetur插件的，另一次是ESlint的，应该去掉其中一个以节省性能和时间。一般选择去掉Vetur的，因为ESlint格式化出阿来的JS才符合ESlint的规则，不容易报红。所以加入 “vetur.format.defaultFormatter.js”: “none”以屏蔽Vetur的JS格式化。<br>    3.ESlint不会格式化Vue文件中的模板部分，但是会监测….所以设置Vetur的HTML格式化风格时应尽量选择与ESlint的更友好的Prettier风格，即以上选项。<br>    4.Vetur下的css和其它css预处理语言默认使用Prettier风格，所以这里不用自行配置。</p><p>完成以上配置后，就能愉快的写代码了~~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> VSCode </tag>
            
            <tag> 自动格式化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git的日常工作流程总结</title>
      <link href="/2018/11/28/git%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/28/git%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了一下在团队开发种自己日常使用的一下git操作以及流程：<br><a id="more"></a><br><pre><code>&#x2F;&#x2F; 去自己的工作分支$ git checkout work&#x2F;&#x2F; 工作&#x2F;&#x2F; ....&#x2F;&#x2F; 提交工作分支的修改$ git commit -a&#x2F;&#x2F; 回到主分支$ git checkout master&#x2F;&#x2F; 获取远程最新的修改，此时不会产生冲突$ git pull&#x2F;&#x2F; 回到工作分支$ git checkout work&#x2F;&#x2F; 用rebase合并主干的修改，如果有冲突在此时解决$ git merge master&#x2F;&#x2F; 回到主分支$ git checkout master&#x2F;&#x2F; 合并工作分支的修改，此时不会产生冲突。$ git merge work&#x2F;&#x2F; 提交到远程主干$ git push</code></pre></p><p>这样做的好处是，远程主干上的历史永远是线性的。每个人在本地分支（本地master和本地work）解决冲突，不会在主干上产生冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决VSCode触摸板卡顿问题</title>
      <link href="/2018/07/29/%E8%A7%A3%E5%86%B3VSCode%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/29/%E8%A7%A3%E5%86%B3VSCode%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Setting.json中增加选项：<br><pre><code>&quot;window.smoothScrollingWorkaround&quot;: true,&quot;window.titleBarStyle&quot;: &quot;native&quot;</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--模板TemplatedMixin</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BFTemplatedMixin/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BFTemplatedMixin/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;_TemplatedMixin(params,srcNodeRef) 用于模板实例化的部件的混合<a id="more"></a><br>&emsp;&emsp;on方法不需要前缀。包括三个参数。<br>@param: params<br>&emsp;&emsp;类型：Object | null<br>&emsp;&emsp;&emsp;&emsp;描述：部件的初始化参数哈希值，包括标量值（如标题，持续时间等）和函数，通常是onClick之类的回调。<br>&emsp;&emsp;&emsp;&emsp;哈希可以包含任何窗口小部件的属性，不包括只读属性。<br>@param: srcNodeRef<br>&emsp;&emsp;类型：DOMNode | String<br>&emsp;&emsp;描述：可选的。如果指定了srcNodeRef（DOM节点），则将srcNodeRef替换为方法生成的DOM树。<br><pre><code>require([            &#39;dojo&#x2F;dom&#39;,            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &quot;dijit&#x2F;_WidgetBase&quot;,            &#39;dijit&#x2F;_TemplatedMixin&#39;,            &#39;dojo&#x2F;domReady!&#39;        ], function (dom, declare, _WidgetBase, _TemplatedMixin) {            &#x2F;&#x2F; 用法            var foo = new _TemplatedMixin(params, srcNodeRef);            &#x2F;&#x2F; 属性            &#x2F;&#x2F; attachScope：附加点和事件将作用于的对象。 默认为&#39;this&#39;。            &#x2F;&#x2F; searchContainerNode            &#x2F;&#x2F; templatePath: 相对于dojo.baseUrl的此部件的模板（HTML文件）的路径。 不推荐：使用带有require（[...“dojo &#x2F; text！...”]，...）的templateString代替            &#x2F;&#x2F; templateString: 表示窗部件html模板的字符串。 与dojo.cache()结合使用以从文件加载。            &#x2F;&#x2F; 方法            &#x2F;**             *  buildRendering() 解析HTML模板，从模板构造此部件的UI，设置this.domNode。             *&#x2F;            &#x2F;**             *  destroyRendering() 销毁部件的DOM。             *&#x2F;            &#x2F;**             * getCachedTemplate(templateString,alwaysUseString,doc) 根据templatePath或templateString键获取模板的静态方法             * @param: templateString             *         类型：String             *         描述：模板             * @param: alwaysUseString             *         类型：Boolean             *         描述：不要为此模板缓存DOM树，即使它没有任何变量             * @param: doc             *         类型：Document             *         描述：可选的。目标文件。 如果未指定，则默认为全局文档。             *&#x2F;            &#x2F;**             * 大部分的dijit部件都混入了dijit&#x2F;_TemplatedMixin。它需要一个HTML模板，并根据该模板创建小部件的DOM树。             * 换言之，它为你实现了buildRendering()这个方法。请注意，名称中的下划线表示_TemplatedMixin不是私有类，             * 而是它是一个mixin，而不是一个小部件。             *&#x2F;            &#x2F;&#x2F; 用法            &#x2F;&#x2F; 声明部件时混入dijit &#x2F; _TemplatedMixin，然后定义一个templateString。            declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                templateString: &quot;&lt;div&gt;hello world&lt;&#x2F;div&gt;&quot;            });            &#x2F;&#x2F; 模板            &#x2F;&#x2F; 模板在widget属性templateString中指定，并指向具有单个根节点的，在标签上具有特殊属性，可能还有替换变量的            &#x2F;&#x2F; 某个HTML。            &#x2F;&#x2F; 它可以指定为字符串：            declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                templateString: &quot;&lt;div&gt;hello world&lt;&#x2F;div&gt;&quot;            });            &#x2F;&#x2F; 或使用dojo&#x2F;text!从文件中提取插入：            require([                &quot;dojo&#x2F;declare&quot;,                &quot;dijit&#x2F;_WidgetBase&quot;,                &quot;dijit&#x2F;_TemplatedMixin&quot;,                &quot;dojo&#x2F;text!myNameSpace&#x2F;templates&#x2F;MyWidget.html&quot;            ], function (declare, _WidgetBase, _TemplatedMixin, template) {                declare(&quot;MyWidget&quot;, [_WidgetBase, _TemplatedMixin], {                    templateString: template,                });            });            &#x2F;&#x2F; 构建或发布的Dijit树时，调用字符串将internStrings转换为dojo&#x2F;text！，避免在用户加载部件时网络请求。            &#x2F;**             * 除了像class这样的典型属性外，模板中的标签还可以具有这些特殊属性：             * 1.data-dojo-attach-point             * 2.data-dojo-attach-event             *              * data-dojo-attach-point             * 在widget的JavaScript中，你可能希望直接引用具有某些html模板的dom节点，在这种情况下，widget将需要             * 使用统计访问&lt;span&gt;以更改值。             * 你可能认为窗口小部件作者可以在html模板中使用id属性，然后在部件的js中使用dojo.byId()。 但如果             * 这样做，在创建了两个或更多个部件实例时，它们都将具有相同的id, 很显然代码会出错。             * 相反，你的部件需要执行以下操作：             *      1.在部件模板的html中，对于这些变量应该对应的每个节点，需要添加属性：data-dojo-attach-point =&quot;yourVariableNameHere&quot;。             *      2.在部件的js代码中使用这些节点的变量(未声明)。在这种情况下将会访问this.counter。             * 变量未声明的原因是，当_TemplatedMixin中的代码在上面的步骤1中扫描html，并且它在data-dojo-attach-point             * 属性中找到变量时，它会动态地将这些变量添加到窗口小部件类中。             *              * data-dojo-attach-event             * data-dojo-attach-event将自动从DOM节点上的事件建立连接（在本例中为onclick），以调用窗口小部件中的方法（在本例中为increment（））。             * 以下是data-dojo-attach-point和data-dojo-attach-event的示例：             **&#x2F;            require([                &quot;dojo&#x2F;declare&quot;, &quot;dojo&#x2F;parser&quot;,                &quot;dijit&#x2F;_WidgetBase&quot;, &quot;dijit&#x2F;_TemplatedMixin&quot;, &quot;dojo&#x2F;domReady!&quot;            ], function (declare, parser, _WidgetBase, _TemplatedMixin) {                parser.parse();                return declare(&quot;FancyCounter&quot;, [dijit._WidgetBase, dijit._TemplatedMixin], {                    &#x2F;&#x2F; counter                    _i: 0,                    templateString:                        &quot;&lt;div&gt;&quot; +                        &quot;&lt;button data-dojo-attach-event=&#39;onclick: increment&#39;&gt;press me&lt;&#x2F;button&gt;&quot; +                        &quot;&amp;nbsp; count: &lt;span data-dojo-attach-point=&#39;counter&#39;&gt;0&lt;&#x2F;span&gt;&quot; +                        &quot;&lt;&#x2F;div&gt;&quot;,                    increment: function (evt) {                        this.counter.innerHTML = ++this._i;                    }                });                &#x2F;**                 * containerNode                 * 通常在标记中声明的部件将包含一些其他DOM。例如                 * &lt;button data-dojo-type=&quot;dijit&#x2F;form&#x2F;Button&quot;&gt;press me&lt;&#x2F;button&gt;                 *                  * 如果模板定义了data-dojo-attach-point =&quot;containerNode&quot;，则srcNodeRef中的子节点将被复制到此节点。                 * 例如                 **&#x2F;                require([                    &quot;dojo&#x2F;declare&quot;, &quot;dojo&#x2F;parser&quot;,                    &quot;dijit&#x2F;_WidgetBase&quot;, &quot;dijit&#x2F;_TemplatedMixin&quot;, &quot;dojo&#x2F;domReady!&quot;                ], function (declare, parser, _WidgetBase, _TemplatedMixin) {                    parser.parse();                    return declare(&quot;MyButton&quot;, [dijit._WidgetBase, dijit._TemplatedMixin], {                        templateString:                            &quot;&lt;button data-dojo-attach-point=&#39;containerNode&#39; data-dojo-attach-event=&#39;onclick: onClick&#39;&gt;&lt;&#x2F;button&gt;&quot;,                        onClick: function (evt) {                            alert(&quot;Awesome!!&quot;);                        }                    });                });                &#x2F;&#x2F; Substitution variables(替代变量)                &#x2F;&#x2F; 模板也可以引用替换变量，如$ {title}。 $ {title}引用窗口小部件的title属性。                &#x2F;&#x2F; 但是，不推荐这样做，因为它只处理小部件实例化的标题设置。换言之，如果使用替换变量，                &#x2F;&#x2F; myWidget.set（&#39;title&#39;，&#39;myNewTitle&#39;）将不起作用。                &#x2F;&#x2F; 常见的陷阱                &#x2F;&#x2F; 1.确保模板中只有一个根节点                &#x2F;&#x2F; 2.不要使用注释启动模板（或结束它）（因为这在技术上意味着有两个节点）                &#x2F;&#x2F; 3.避免在模板末尾使用&lt;&#x2F; div&gt;            });        })</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> _TemplatedMixin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--创建widget</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BAwidget/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BAwidget/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dijit / _WidgetBase是Dijit包中所有组件的基类，也是Dojo中所有组件的一个基类。通常一个组件也会继承一些属性融合的工具类，例如：dijit._TemplatedMixin。 注意：_WidgetBase名字中的下划线表示它是一个基类，不可直接使用，而不是表示它是一个私有的类。<a id="more"></a>_WidgetBase是一个不可以直接使用的基类，需要继承。一般在创建dojo自定义组件时，继承来自_WidgetBase基类的属性和方法，它的作用是赋予自定义组件一些常用些属性，给你的组件创建生命周期以及提供一些操作组件的API。<br><pre><code>require([            &quot;dojo&quot;,            &#39;dojo&#x2F;dom&#39;,            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &#39;dijit&#x2F;_WidgetBase&#39;,            &#39;dijit&#x2F;form&#x2F;TextBox&#39;,            &#39;dijit&#x2F;form&#x2F;Button&#39;,            &#39;demo&#x2F;test&#39;,            &#39;dijit&#x2F;Dialog&#39;,            &#39;dojo&#x2F;on&#39;,            &#39;dojo&#x2F;domReady!&#39;        ], function (dojo, dom, declare, WidgetBase, TextBox, Button, test, Dialog, on) {            &#x2F;&#x2F; 用法            &#x2F;&#x2F; Dojo中所有的组件通过调用dojo.declare()继承_WidgetBase，然后根据组件的生命周期定义大量的方法。            declare(&quot;MyWidget&quot;, WidgetBase, {                &#x2F;&#x2F;do something            });            &#x2F;&#x2F; 部分属性            &#x2F;&#x2F; id: 标识微件的String类型的唯一值            &#x2F;&#x2F; lang: 很少使用的String值，可以重写Dojo默认的locale            &#x2F;&#x2F; dir: 用于双向支持            &#x2F;&#x2F; class: 部件domNode的html样式            &#x2F;&#x2F; style: 部件domNode的style属性            &#x2F;&#x2F; title: 一般表示原生提示的html title属性            &#x2F;&#x2F; baseClass：部件的根CSS样式            &#x2F;&#x2F; srcNodeRef: 部件在部件化之前的原始Dom 节点，如果有的话。注意这个属性与部件的类型有关(如基于模板的微件)，并且在postCreate之后可能会被丢弃。            &#x2F;&#x2F; tooltip：widget 根节点上的 class, 用来创建指示 widget 状态(State)的 css classes            &#x2F;&#x2F; 部分方法            &#x2F;**            * defer(fcn,delay) 包装到setTimeout以避免在销毁原始窗口小部件后执行delay函数。 使用remove方法返回一个对象句柄。            * @param: fcn            *         类型: Function            *         描述：   参考函数。            * @param：delay            *         类型：Number            *         描述：延迟时间，默认为0。            *&#x2F;            &#x2F;&#x2F; constructor（构造方法）            &#x2F;&#x2F; 在根据传入参数初始化组件之前，构造方法就会被调用。所以说，在构造方法中你可以进行数组初始化等操作。            &#x2F;&#x2F; buildRendering（渲染组件）            &#x2F;&#x2F; dijit._TemplatedMixin提供buildRendering实现你想要实现的组件。此方法执行后，模板会被加载、节点会被创建、事件也会被绑定，最终的结果就是完成节点的展示。如果你没有混入类dijit._TemplateMinxin（通常OOTB dijit会去做），而且希望自己去渲染组件（例如：简化一个组件，或者更换系统模板），你就可以在这个方法中实现。            &#x2F;&#x2F; API中描述：构造组件的UI，并应用到this.domNode。大多数需要重写这个方法的组件都需要继承类dijit._TemplateMinxin。            &#x2F;&#x2F; setters are called（执行setXXX方法）            &#x2F;&#x2F; 类中定义的_setXXX方法会在此时被执行，不管在构造函数中或者为non-null non-blank non-zero类型数据设定默认值，这个方法都会执行。            &#x2F;&#x2F; postCreate（创建组件）            &#x2F;&#x2F; 这个方法是一个组件创建成功的关键步骤，这个组件已经被渲染（注意：如果是容器，那么容器内的组件还未被渲染），并且此组件还未依附到一个DOM节点上，所以在这个方法中你不能进行任何布局相关的计算。            &#x2F;&#x2F; API描述：在组件片创建之后执行，但是不一定已经添加到HTML文档中（通过placeAt()指定依附节点），这个方法不包括管理大小和位置的任何计算。            &#x2F;&#x2F; startup()            &#x2F;&#x2F; 如果你确认所有的子组件已经完成解析、创建，你就可以调用startup()方法。这个方法通常用于布局相关的的组件，例如：BorderContainer。如果组件需要通过JS进行布局计算，那么就可以在startup()中调用resize()方法进行布局处理。            &#x2F;&#x2F; API描述：在组件片已经添加到文档之后执行，并且所有相关的组件已经执行完postCreate()方法。注意：startup()方法可能在组件隐藏的时候被调用，例如：一个隐藏状态的对话框dijit&#x2F;Dialog，或者一个隐藏状态的Tab页dijit&#x2F;layout&#x2F;TabContainer，对于这些组件，如果你想重新布局，最好将相关代码放到resize()方法中，并且继承dijit&#x2F;layout&#x2F;_LayoutWidget，当组件显示的时候，resize()方法就会被调用。            &#x2F;&#x2F; 例子            var button = new Button({                label: &#39;Button2&#39;,                onClick: function () { console.log(&quot;Button2 Clicked.&quot;); }            }, &quot;btn2&quot;);            button.startup();            &#x2F;**            * destroy(preserveDom) 此方法可以进行销毁数据，一般父类都会自动的调用此方法销毁对象，但不包括对象的后代。            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将仅保留原始DOM结构。 注意：这不适用于_TemplatedMixin小部件            *&#x2F;            &#x2F;&#x2F;例子            var widget = new TextBox({ name: &quot;firstname&quot; }, &quot;inputId&quot;);            widget.destroy();            dijit.byId(&quot;dijitId&quot;).destroy();            &#x2F;**            * destroyDescendants(preserveDom) 递归销毁这个小部件及其后代的子节点            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则preserveDom属性将传递给所有后代窗口小部件的.destroy（）方法。 不适用于_Templated小部件。            *&#x2F;            &#x2F;**            * destroyRecursive(preserveDom) 销毁此小部件及其后代            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将使原始DOM结构独立于后代Widgets。 注意：这不适用于dijit._TemplatedMixin小部件。            *&#x2F;            &#x2F;**            * destroyRendering(preserveDom) 销毁与此窗口小部件关联的DOM节点。            * @param: preserveDom            *         类型：Boolean            *         描述：如果为true，则此方法将在销毁期间单独保留原始DOM结构。 注意：这不适用于_TemplatedMixin小部件。            *&#x2F;            &#x2F;**            * get(name) 从小部件获取某个属性的值。            * @param: name            *         类型：undefined            *         描述：要获取值的属性名。            *&#x2F;            &#x2F;**            * getChildren()  返回包含此部件的所有直接子部件的简单数组，不会返回所有后代，而只是直接返回子项，无法使用foreach遍历。            *&#x2F;            &#x2F;**            * getParent() 返回部件的父部件。            *&#x2F;            &#x2F;**            * isFocusable() 如果此部件当前可以聚焦则返回true，否则返回false            *&#x2F;            &#x2F;**            * placeAt(reference,position) 根据标准domConstruct.place（）约定将此部件放在DOM中的某个位置。            * @param: reference            *         类型：String | DomNode | DocumentFragment | dijit&#x2F;_WidgetBase            *         描述：窗口小部件，DOMNode，DocumentFragment，部件或DOMNode的ID            * @param: position            *         类型：String | Int            *         描述：可选的            *               如果引用是窗口小部件（或窗口小部件的id），并且该窗口小部件具有“.addChild”方法，则会调用它将此窗口小部件实例传递到该方法，并提供传递的可选位置索引。 在这种情况下，position（如果指定）应该是一个整数。            *               如果引用是DOMNode（或id匹配DOMNode而不是小部件），则position参数可以是数字索引或字符串“first”，“last”，“before”或“after”，与dojo &#x2F; dom相同-construct::地方（）。            *&#x2F;            &#x2F;&#x2F; Example 1            &#x2F;&#x2F; create a Button with no srcNodeRef, and place it in the body:            var button = new Button({ label: &quot;click&quot; }).placeAt(win.body());            &#x2F;&#x2F; now, &#39;button&#39; is still the widget reference to the newly created button            button.on(&quot;click&quot;, function (e) { console.log(&#39;click&#39;); });            &#x2F;&#x2F; Example 2            &#x2F;&#x2F; create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:            var button = new Button({}, &quot;src&quot;).placeAt(&quot;wrapper&quot;);            &#x2F;&#x2F; Example 3            &#x2F;&#x2F; place a new button as the first element of some div            var button = new Button({ label: &quot;click&quot; }).placeAt(&quot;wrapper&quot;, &quot;first&quot;);            &#x2F;&#x2F; Example 4            &#x2F;&#x2F; create a contentpane and add it to a TabContainer            var tc = dijit.byId(&quot;myTabs&quot;);            new ContentPane({ href: &quot;foo.html&quot;, title: &quot;Wow!&quot; }).placeAt(tc);            &#x2F;**            * set(name,value) 设置部件某个属性。            * @param: name            *         类型：undefined            *         描述：要设置的属性名。            * @param: value            *         类型：undefined            *         描述：要设置的属性值。            *&#x2F;            &#x2F;**            * toString() 返回表示窗口小部件的字符串。            *&#x2F;            &#x2F;**            * watch(name,callback) 检测属性是否变更。            * @param: name            *         类型：String            *         描述：可选。表示要监视的属性。如果省略，将监视所有属性            * @param: callback            *         类型：Function            *         描述：属性更改时要执行的函数。             *&#x2F;            &#x2F;&#x2F;事件            &#x2F;**            * onBlur() 当部件因为焦点移动到其外部或者用户在其外部的某处单击或者窗口小部件被隐藏而停止“活动”时调用。            *&#x2F;            &#x2F;&#x2F; Example 1            var btn = new Button();            &#x2F;&#x2F; when &#x2F;my&#x2F;topic is published, this button changes its label to            &#x2F;&#x2F; be the parameter of the topic.            btn.subscribe(&quot;&#x2F;my&#x2F;topic&quot;, function (v) {                this.set(&quot;label&quot;, v);            });            &#x2F;**            * onFocus() 当部件因为它或其内部的窗口小部件具有焦点或者最近被单击而开始“活动”时调用。            *&#x2F;            &#x2F;&#x2F; Example 1            var btn = new Button();            &#x2F;&#x2F; when &#x2F;my&#x2F;topic is published, this button changes its label to            &#x2F;&#x2F; be the parameter of the topic.            btn.subscribe(&quot;&#x2F;my&#x2F;topic&quot;, function (v) {                this.set(&quot;label&quot;, v);            });            &#x2F;&#x2F;widget例子            var te = new test({}, &quot;base&quot;);            setTimeout(() =&gt; {                te.destroy(true);            }, 1000);        })</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> widget </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--Deferred对象</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Deferred%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Deferred%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dojo.Deferred管理异步线程（回调）之间的通信。 dojo.Deferred封装了一系列回调以响应可能尚未可用的值。 所有dojo.xhr*函数都使用此类(Deferred)，其他许多函数也是如此，例如dojo.io.script。<a id="more"></a><br><pre><code>require([            &#39;dojo&#39;,            &#39;dojo&#x2F;_base&#x2F;Deferred&#39;,            &#39;dojo&#x2F;dom&#39;        ], function (dojo, Deferred, dom) {            &#x2F;&#x2F; 官方：从1.09开始不再建议使用dojo&#x2F;_base&#x2F;Deferred，改用dojo&#x2F;Deferred.            &#x2F;&#x2F; dojo.Deferred是一个对象，允许用户为可能无法立即完成的任务分配成功和错误条件的回调函数。             &#x2F;&#x2F; 这些任务通常是通过调用dojo.xhrGet和其他异步操作的IO函数生成的。            &#x2F;&#x2F; 基本前提是这个异步任务（甚至是同步任务）可以返回dojo.Deferred的实例。然后，用户可以调用            &#x2F;&#x2F; then()来为Deferred分配回调函数，回调函数可以有两个(Deferred.then(success_callback, error_callback))。            &#x2F;&#x2F; 如果在执行Deferred之后调用then()函数，则Deferred将立即根据任务结果(成功或错误)调用相应的            &#x2F;&#x2F; 回调函数。一般then()的第一个参数为返回成功时执行的回调函数，第二个参数为返回错误时执行的回            &#x2F;&#x2F; 调函数并且是可选的。            &#x2F;&#x2F; 使用dojo.Deferred非常简单。当你想提供一个函数作为返回时调用，你只需调用then()并            &#x2F;&#x2F; 将then()交给一个函数，以便在触发Deferred时执行。如果你想创建一个Deferred，则只需            &#x2F;&#x2F; new一个实例并将其返回给调用者。当Deferred完成时将调用callback或者errback，此时的回调函数            &#x2F;&#x2F; 返回的又是一个Deferred对象，所以可以多次使用回调函数直至你想要的结果。            &#x2F;&#x2F;创建和调用Deferred            var deferred = new Deferred();            setTimeout(function () {                deferred.resolve({                    success: true                });            }, 1000);            console.log(deferred);            &#x2F;&#x2F;在Deferred触发时指定要触发的回调            &#x2F;&#x2F; var deferred = someAsyncFunction();            &#x2F;&#x2F; deferred.then(            &#x2F;&#x2F;     function (value) {            &#x2F;&#x2F;         &#x2F;&#x2F; Do something on success.            &#x2F;&#x2F;     },            &#x2F;&#x2F;     function (error) {            &#x2F;&#x2F;         &#x2F;&#x2F; Do something on failure.            &#x2F;&#x2F;     }            &#x2F;&#x2F; );            &#x2F;&#x2F; when()方法            &#x2F;&#x2F; when() 函数是与Deferred对象交互的有用工具，因为它可以提供异步Deferred和正常同步值之间的规范化。            &#x2F;&#x2F; 在Dojo 1.7中，when函数作为dojo &#x2F; _base &#x2F; Deferred模块返回（也是Deferred构造函数）的成员公开，            &#x2F;&#x2F; 但在Dojo 1.8中，模块已经移动到自己的位置。            Deferred.when(4, print); &#x2F;&#x2F; this will print 4 immediately            function print(value) {                console.log(value);            };            var fourAsync = new Deferred();            Deferred.when(fourAsync, print); &#x2F;&#x2F; this will print 4, one second later when the Deferred is resolved            setTimeout(function () {                fourAsync.resolve(4);            }, 1000);            &#x2F;&#x2F; Deferred API基于promise的概念，它为最终完成异步操作提供了通用接口。 promise的动机从根本上讲是创建一个            &#x2F;&#x2F; 关注点的分离，允许人们在同步代码中实现与异步代码相同类型的调用模式和逻辑数据流。Promise的参数允许是纯粹            &#x2F;&#x2F; 的函数。 如果实现从同步切换到异步（或反之亦然），则不应该更改调用的参数。             &#x2F;&#x2F; Deferred是一种promise，它提供了通过成功结果或错误来履行 promise的方法。 使用Dojo的promises最重要的方            &#x2F;&#x2F; 法是then（）方法，它遵循CommonJS提出的promise API。 一个then()例子被调用后会返回一个新的promise，表示            &#x2F;&#x2F; 执行回调的结果。 回调永远不会影响原始的promises值。            &#x2F;&#x2F; 允许回调自己返回promise，因此可以轻松地构建复杂的事件序列。            &#x2F;&#x2F; Deferred的创建者可以指定一个cancel函数。 如果在Deferred被触发之前调用Deferred.canceler回调函数，则这个            &#x2F;&#x2F; Deferred会被取消，停止执行。例如可以使用它来实现XMLHttpRequest请求中止。请注意，cancel将使用CancelledError            &#x2F;&#x2F; 类型来触发Deferred（除非你的canceller返回另一种error），因此errbacks回调函数应做好取消Deferred错误的准备。            &#x2F;&#x2F;例子            createDeferred = function () {                &#x2F;&#x2F; Create a deferred and set it to fire in 1 second.                var deferred = new Deferred();                setTimeout(function () {                    deferred.resolve({                        called: true                    });                }, 1000);                dom.byId(&quot;response&quot;).innerHTML = &quot;Created a deferred.&quot;;                &#x2F;&#x2F; Add a callback that changes the displayed message after it fires.                deferred.then(function () {                    dom.byId(&quot;response&quot;).innerHTML = &quot;Deferred has fired.&quot;;                });            };            &#x2F;&#x2F; then(resolvedCallback,errorCallback,progressCallback)            &#x2F;&#x2F; then()方法是在Deferred执行后给三个状态(resolve、error、progress，其中error包括reject和cancel)添加回调函            &#x2F;&#x2F; 数的方法。一共可设置三个回调函数，第一参数在调用resolve后回调，第二参数在调用reject和cancel后            &#x2F;&#x2F; 回调，第三参数在调用progress后回调。所有参数都是可选的，忽略非函数值。progressHandler不仅是一个可选参数，            &#x2F;&#x2F; 而且progress事件也是可选的。 promise提供者不需要创建进度事件。            &#x2F;&#x2F; 此方法在resolvedCallback或者errorCallback执行完成时返回一个新的promise，所以可以实现链式操作。回调函数返回            &#x2F;&#x2F; 的值就是promise返回的结果，如果回调引发错误，则返回的promise将会变为错误状态。            &#x2F;&#x2F;例子            asyncComputeTheAnswerToEverything().                then(addTwo).                then(printResult, onError);            &#x2F;&#x2F; 其他的一些方法            &#x2F;&#x2F; 1、resolve：该deferred完成。            &#x2F;&#x2F; 2、reject：该deferred发生错误。            &#x2F;&#x2F; 3、cancel：取消所有回调，即不再关心该deferred对象。            &#x2F;&#x2F; 4、progress：更新deferred对象状态。            &#x2F;&#x2F; 5、isResolved：若调用过resolve函数返回true            &#x2F;&#x2F; 6、isRejected：若调用过reject函数返回true            &#x2F;&#x2F; 7、isFulfilled：若调用过resolve、reject或cancel三者之一返回true            &#x2F;&#x2F; 8、isCanceled：若调用过cancel函数返回true        })</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> Deferred </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--创建类的工具declare</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7declare/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7declare/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;declare(className,superclass,props) 是创建类的基础，es6之前js并不支持创建类，没有关键词class和extends.declare允许开发者实现多继承，从而创建灵活的有弹性的代码，避免重复写代码。<a id="more"></a><br>@param: className<br>&emsp;&emsp;类型: String<br>&emsp;&emsp;描述: 可选。className参数是要创建的这个类的名字，也包括它的命名空间。<br>&emsp;&emsp;&emsp;&emsp;命名类（给定了className, 相对的为匿名类， Named Class）的名字<br>&emsp;&emsp;&emsp;&emsp;会存在于全局作用域， className也可以通过命名空间来表示继承链。<br>&emsp;&emsp;&emsp;&emsp;当省略参数时，创建的类为匿名类，需要使用变量接收。匿名类只在给<br>&emsp;&emsp;&emsp;&emsp;定的作用域有效。<br>@param: superclass<br>&emsp;&emsp;类型: Function | Function[]<br>&emsp;&emsp;描述: SuperClass 参数可以为null(但不能省略)、 单个已存在的类或者多个<br>&emsp;&emsp;&emsp;&emsp;类组成的数组。<br>@param: props<br>&emsp;&emsp;类型: Object<br>&emsp;&emsp;描述: 包含这个类原型方法和原型属性的一个对象。 此参数提供的属性或方法<br>&emsp;&emsp;&emsp;&emsp;如果跟被继承的类的属性或方法同名，那么将会被优先使用。<br><pre><code>require([            &#39;dojo&#x2F;_base&#x2F;declare&#39;,            &#39;dojo&#x2F;_base&#x2F;lang&#39;,            &#39;dojo&#x2F;dom&#39;,            &quot;dijit&#x2F;form&#x2F;Button&quot;,            &quot;dojo&#x2F;domReady!&quot;        ], function (declare, lang, dom, Button) {            &#x2F;&#x2F; className(类名)            &#x2F;&#x2F; 命名类            declare(&quot;mynamespace.Person&quot;, null, {                &#x2F;&#x2F; Custom properties and methods here                method: function () {                    console.log(&quot;命名类&quot;);                }            })            var per = new mynamespace.Person();            per.method();            &#x2F;&#x2F; 匿名类  需要变量名去接收            var Person = declare(null, {                &#x2F;&#x2F; Custom properties and methods here                method: function () {                    console.log(&quot;匿名类&quot;);                }            })            var per = new Person();            per.method();            &#x2F;&#x2F; SuperClass(超类)，继承的优先级从左至右依次升高，若果出现重复属性或方法时，            &#x2F;&#x2F; 时，优先级高的将会被保留，低的将会被覆盖。可以通过declare()的第三个参数添加            &#x2F;&#x2F; 相同的属性或方法名来覆盖你想覆盖掉的东西。            &#x2F;&#x2F;不继承            console.log(&quot;------------不继承-----------&quot;)            declare(&quot;myClass&quot;, null, {                text: &quot;不继承&quot;            });            var myInst = new myClass();            console.log(myInst);            console.log(myInst.text);            &#x2F;&#x2F;单继承            console.log(&quot;------------单继承-----------&quot;)            declare(&quot;mySubClass&quot;, myClass, {                text: &quot;单继承&quot;            });            var myInst = new mySubClass();            console.log(myInst);            console.log(myInst.text)            &#x2F;&#x2F; 多继承            console.log(&quot;------------多继承-----------&quot;)            declare(&quot;myFirstClass&quot;, null, {                num1: &quot;1&quot;,                prop: &quot;a&quot;            });            declare(&quot;mySecondClass&quot;, null, {                num2: &quot;2&quot;,                prop: &quot;b&quot;            });            declare(&quot;myThirdClass&quot;, null, {                num3: &quot;3&quot;,                prop: &quot;c&quot;            });            var Obj = {                num4: &quot;4&quot;,                prop: &quot;d&quot;            }            declare(&quot;myMultiSubClass&quot;, [myFirstClass, mySecondClass, myThirdClass], Obj);            var myInst = new myMultiSubClass();            console.log(myInst);            console.log(myInst.num1 + myInst.num2 + myInst.num3 + myInst.num4 + &quot;,&quot; + myInst.prop);            &#x2F;*                 从myInst打印的情况可以看出，优先级的具体表现就是原型链继承的先后问题，Obj处于                原型链的首位，所以优先级最高，原型链依次往后分别是myThirdClass、mySecondClass、                myFirstClass，前面提到出现重复项时优先级高的class将会覆盖掉优先级低的，其实                严格来讲并不是这样，根据原型链的特性，当检索一个对象实例的属性时，会首先检查实                例自己本身的属性，如果没有，会查找按顺序原型链，如果原型链中某一个对象出现有这个属性，                则直接返回这个属性的值，不再进行查找，如果整个原型链都没有这个属性则返回undefine。                也正是因为这样，多继承类出现重复定义项时，排列在原型链前的将会被直接返回，因为                已经返回，所以永远得不到原型链后面的重复项的值，这个并不是覆盖，重复项还是处于                原型链中，只是得不到而已。                我们可以做个实验直接获取myFirstClass的prop属性，查看它是否还存在以及属性值是                否被改变。            *&#x2F;            console.log(myInst.__proto__.__proto__.__proto__.__proto__.prop)&#x2F;&#x2F;myFirstClass中的prop属性值仍然为&quot;a&quot;            &#x2F;&#x2F; 属性和方法对象            &#x2F;&#x2F; declare方法的最后的参数是包含这个类原型方法和原型属性的一个对象。 此参数提供的            &#x2F;&#x2F; 属性或方法如果跟被继承的类的属性或方法同名，那么将会被优先使用。            &#x2F;&#x2F; 拥有属性和方法的类            declare(&quot;MyClass&quot;, null, {                myProperty1: 12,                myOtherProperty: &quot;Hello&quot;,                myMethod: function () {                    console.log(&quot;World&quot;);                    return result;                }            });            &#x2F;&#x2F;类的创建和继承例子            &#x2F;&#x2F;使用declare()继承dijit&#x2F;form&#x2F;Button组件，并添加label和onClick属性。            declare(&quot;newButton&quot;, Button, {                label: &quot;My Button&quot;,                onClick: function (e) {                    console.log(&quot;I was clicked!&quot;);                }            })            var myButton = new newButton({}, &quot;declare&quot;).startup();            &#x2F;&#x2F; 构造函数 constructor            &#x2F;&#x2F; 类中特别的一个方法就是constructor方法，constructor方法会在类的实例化时触发，在            &#x2F;&#x2F; 新对象的作用域名内执行。如果在constructor中使用this，则这个this则会指向这个类的            &#x2F;&#x2F; 实例，而不是类。constructor接受实例化指定的参数。            console.log(&quot;--------------构造函数-------------&quot;)            declare(&quot;Twitter&quot;, null, {                username: &quot;defaultUser&quot;,                constructor: function (args) {                    declare.safeMixin(this, args);&#x2F;&#x2F;将传入的参数混入到实例对象中                }            })            var myInst = new Twitter();            console.log(myInst.username);&#x2F;&#x2F;输出defaultUser            &#x2F;&#x2F;创建并传入一个对象            var myInst = new Twitter({                username: &quot;Sparrow&quot;            });            console.log(myInst.username);&#x2F;&#x2F;输出Sparrow            &#x2F;&#x2F; 如果继承的原型中属性指向Object或者Array，创建的实例将会指向同一个值。下面来探讨一            &#x2F;&#x2F; 种数据被意外修改的情况            var arr = [1, 2, 3, 4];            declare(&quot;myClass&quot;, null, {                num: arr,                prop: &quot;aaa&quot;            });            var myInst1 = new myClass();            var myInst2 = new myClass();            myInst1.prop = &quot;bbb&quot;; &#x2F;&#x2F;修改num属性            console.log(myInst1.prop); &#x2F;&#x2F; bbb            console.log(myInst2.prop); &#x2F;&#x2F; aaa            &#x2F;&#x2F; 此时实际上时给myInst新增了一个prop属性，并没有操作原型链中的prop属性，所以myInst2.prop并没有被修改            myInst1.__proto__.prop = &quot;bbb&quot;;            console.log(myInst1.prop); &#x2F;&#x2F; bbb            console.log(myInst2.prop); &#x2F;&#x2F; bbb            &#x2F;&#x2F; 操作原型链时，其他实例也会受到影响，这种情况一般不会发生            myInst1.num = [4, 5, 6, 7];            console.log(myInst1.num); &#x2F;&#x2F; [4,5,6,7]            console.log(myInst2.num); &#x2F;&#x2F; [1,2,3,4]            &#x2F;&#x2F; 此时实际上时给myInst新增了一个num属性，并没有操作原型链中的num属性，所以myInst2.num并没有被修改            delete myInst1.num;&#x2F;&#x2F;删除num属性，以下的myInst1已经没有这个属性            myInst1.num.push(5);            console.log(myInst1.num); &#x2F;&#x2F; [1,2,3,4,5]            console.log(myInst2.num); &#x2F;&#x2F; [1,2,3,4,5]            &#x2F;&#x2F; push一个元素进myInst1.num时，myInst2.num也受到了影响，因为实例本身没有这个属性，            &#x2F;&#x2F; 所以push操作的实际上是原型链中的num，为了避免这种非故意的修改共享数据，对象的属性            &#x2F;&#x2F; 声明为null，然后在构造函数constructor中对它进行初始化。当然这是网上的一种说法，经            &#x2F;&#x2F; 过实践得出这说法不完全可靠。            console.log(&quot;-------------使用构造函数改造--------------&quot;)            &#x2F;&#x2F;情况1            var arr2 = [1, 2, 3, 4];            declare(&quot;myClass&quot;, null, {                numArr: null,                prop: null,                constructor: function (arr) {                    this.numArr = arr;                    this.prop = &quot;aaa&quot;;                }            });            var myInst1 = new myClass([1, 2, 3, 4]);            var myInst2 = new myClass([1, 2, 3, 4]);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4]            &#x2F;&#x2F; 如果使用传参的方式进行初始化，并且是匿名数组，那么改变myInst1时并不会对myInst2造成影响            var myInst1 = new myClass(arr2);            var myInst2 = new myClass(arr2);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4，5]            &#x2F;&#x2F; 如果使用传递的参数不是匿名数组，那么同样会出现误改数据的情况            &#x2F;&#x2F; 原因很简单，无论怎样初始化，数组类型的引用特性是不会改变的，&quot;this.numArr = arr2&quot;只是起            &#x2F;&#x2F; 到一个把numArr指向arr2的作用，无论this的对象是谁。可以了解一下浅拷贝和引用类型的特性            &#x2F;&#x2F; 便可知道。若果要使用共享的数据而不希望出现误改，根本的解决办法是使用深度拷贝，把arr2的值            &#x2F;&#x2F; 完完整整的拷贝过来而不是使用指针。但这样的一个缺点就是当arr或者obj占用空间很大时，使用            &#x2F;&#x2F; 深度拷贝之后的空间会翻倍，所以应该谨慎使用，或者使用完之后应该及时销毁。            declare(&quot;myClass&quot;, null, {                numArr: null,                prop: null,                constructor: function (arr) {                    this.numArr = lang.clone(arr);&#x2F;&#x2F;clone()是dojo&#x2F;_base&#x2F;lang的一个深度拷贝工具。                    this.prop = &quot;aaa&quot;;                }            });            var myInst1 = new myClass(arr2);            var myInst2 = new myClass(arr2);            &#x2F;&#x2F;push一个5进myInst1.num            myInst1.numArr.push(5);            console.log(myInst1.numArr); &#x2F;&#x2F; [1, 2, 3, 4, 5]            console.log(myInst2.numArr); &#x2F;&#x2F; [1, 2, 3, 4]            &#x2F;&#x2F; this.inherited() 虽然重写一个方法确实有用， 但每一个类的的构造函数都应该执行它继承链中的            &#x2F;&#x2F; 父类构造函数，以保持它原始的功能。 这样this.inherited(arguments)语句就派上用场了。              &#x2F;&#x2F; this.inherited(arguments)语句调用父类的同名方法。             var A = declare(null, {                myMethod: function () {                    console.log(&quot;Hello!&quot;);                }            });            var B = declare(A, {                myMethod: function () {                    &#x2F;&#x2F; 调用父类A中同名的方法                    this.inherited(arguments); &#x2F;&#x2F; arguments指的就是在父类A中定义的myMethod                    console.log(&quot;World!&quot;);                }            });            var myB = new B();            myB.myMethod();            &#x2F;&#x2F;      Hello!            &#x2F;&#x2F;      World!        })</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> declare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--通用工具lang</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7lang/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7lang/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;dojo/base/lang模块是一个通用工具模块，主要提供以下的工具函数<br><a id="more"></a><br><pre><code>require([&#39;dojo&#39;, &#39;dojo&#x2F;_base&#x2F;lang&#39;, &#39;dojo&#x2F;_base&#x2F;declare&#39;, &#39;dojo&#x2F;dom&#39;, &#39;dojo&#x2F;dom-attr&#39;, &quot;dojo&#x2F;domReady!&quot;],    function (dojo, lang, declare, dom, attr) {        &#x2F;*            clone(src)  克隆任何对象或者元素节点，返回一个全新的匿名对象，该对象具有被克隆对象的所有属性和方法，                        而不是指向性的，属于深拷贝。注意：无法克隆循环结构。                @param: src                         类型: anything                        描述: 克隆目标.        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;------------------------- lang.clone -----------------------------&#39;)        var Obj1 = {            firstName: &#39;李&#39;,            lastName: &#39;小龙&#39;        }        var Obj2 = lang.clone(Obj1);        console.log(Obj2);        Obj2.firstName = &#39;张&#39;;        Obj2.lastName = &#39;学友&#39;;        console.log(Obj2);        console.log(Obj1);&#x2F;&#x2F;修改Obj2后Obj1并未受到影响，因为是深拷贝        var node = dom.byId(&#39;someNode&#39;);        var newNode = lang.clone(node);        &#x2F;&#x2F;attr.set给newNode添加属性&quot;id:someNewId&quot;        var newNode = attr.set(newNode, &quot;id&quot;, &quot;someNewId&quot;);        &#x2F;&#x2F;把newNode插在node节点之前，两者为兄弟节点        dojo.place(newNode, node, &quot;before&quot;);        &#x2F;*            delegate(obj, props) 返回一个新的匿名对象，该对象指向(代理)obj对象。当props对象            不为空时将其混入新对象中，并且会进行覆盖。新对象能够访问props的原有属性和方法。                @param: obj                         类型: Object                        描述: 被代理的对象。                @param: props                         类型: Object                        描述: 该对象的属性将会被添加至delegate()返回的对象。        *&#x2F;        &#x2F;&#x2F;创建实例        console.log(&#39;------------------------- lang.delegate -----------------------------&#39;);        var anOldObject = { bar: &quot;baz&quot; };        &#x2F;&#x2F; 创建anNewObject对象作为anOldObject对象的代理对象，并且增加thud:&#39;xyzzy&#39;属性。        var anNewObject = lang.delegate(anOldObject, { thud: &quot;xyzzy&quot; });        console.log(anNewObject);        console.log(anNewObject.bar === &quot;baz&quot;);&#x2F;&#x2F; true        &#x2F;&#x2F; 关键 增加thud属性时并没有影响anOldObject对象，这就是代理的作用，希望给对象新增方法或属性        &#x2F;&#x2F; 进行下一步操作,然而不想改变原有对象的前提下，可以使用delegate()方法实现        console.log(anOldObject.thud === &quot;xyzzy&quot;); &#x2F;&#x2F; false        console.log(anNewObject.thud === &quot;xyzzy&quot;); &#x2F;&#x2F; true         anOldObject.bar = &quot;thonk&quot;;        console.log(anNewObject.bar === &quot;thonk&quot;); &#x2F;&#x2F; true        &#x2F;&#x2F; 源码        delegate: (function () {            &#x2F;&#x2F; 临时构造函数            function TMP() { }            &#x2F;&#x2F; 返回一个匿名函数，该函数其实就是dojo.delegate函数            return function (obj, props) {                TMP.prototype = obj;                var tmp = new TMP();                &#x2F;&#x2F; 虽然TMP.prototype重新置为null，但是tmp对象已经创建出来了，其[[prototype]]属性已经指向了obj，                &#x2F;&#x2F; 所以通过tmp对象可以访问到obj对象中的属性                TMP.prototype = null;                &#x2F;&#x2F; 如果props存在，则将props混入tmp对象中，所以tmp对象中就有了props对象的所有属性                if (props) {                    d._mixin(tmp, props);                }                return tmp; &#x2F;&#x2F; 返回tmp对象            };        });        &#x2F;*            exists(name, obj) 返回值：布尔类型。判断对象是否存在某个方法或属性。                @param: name                         类型: String                        描述: &#39;A.B.C&#39;形式的对象路径.                @param: obj                         类型: Object                        描述: 可选。可使用该参数指定name的根路径。                            参数为空时默认使用 dojo&#x2F;_base&#x2F;kernel::global ，通常是当前的window对象。        *&#x2F;        &#x2F;&#x2F;实例        &#x2F;&#x2F; define an object        console.log(&#39;------------------------- lang.exists -----------------------------&#39;)        var foo = {            bar: {}        };        &#x2F;&#x2F; 从全局作用域判断属性是否存在        console.log(lang.exists(&quot;foo.bar&quot;)); &#x2F;&#x2F; true        console.log(lang.exists(&quot;foo.bar.baz&quot;)); &#x2F;&#x2F; false        &#x2F;&#x2F; 从foo作用域判断属性是否存在        console.log(lang.exists(&quot;bar&quot;, foo)); &#x2F;&#x2F; true        console.log(lang.exists(&quot;bar.baz&quot;, foo)); &#x2F;&#x2F; false        &#x2F;*            extend(ctor,props) 将props对象的所有属性和方法添加到构造函数的原型中，使通过构造函数创建                的实例都可以使用这些属性和方法。                @param: ctor                         类型: Object                        描述: 要扩展的目标构造函数。                @param: props                         类型: Object                        描述: 混入ctor构造函数原型的一个或者多个对象。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;------------------------- lang.extend -----------------------------&#39;)        function per(name) {            this.name = name;        };        lang.extend(per, {            prop: &quot;穷的只剩下钱&quot;,            method: function () {                console.log(&quot;除了赚钱什么也不会&quot;)            }        })        var Obj = new per(&quot;股民巴菲特&quot;);        console.log(Obj.name);        console.log(Obj.prop);        Obj.method();        &#x2F;*            getObject(name,create,context) 返回属性或者方法的值。从点分隔的字符串中获取属性，如&quot;A.B.C&quot;。                @param: name                         类型: String                        描述: &quot;A.B.C&quot;形式的属性的路径。                @param: create                         类型: Boolean                        描述: 可选。默认为false。如果为true，name属性未定义时，则会在该路径创建该属性,如果该                                路径不存在，则会沿着该路径的每一级创建一个对应的空对象，直至路径尽头为止。                @param: context                         类型: Object                        描述: 可选。可使用该参数指定name的根路径，降低代码繁冗度。参数为空时默认使用                                dojo&#x2F;_base&#x2F;kernel::global ，通常是当前的window对象。        *&#x2F;        console.log(&#39;------------------------- lang.getObject -----------------------------&#39;)        &#x2F;&#x2F; 定义一个全局变量        var bar = {}        obj = {            bar: &quot;Russia 2018&quot;,            &#x2F;&#x2F; bar: bar        };        console.log(lang.getObject(&quot;obj.bar&quot;)); &#x2F;&#x2F; returns &quot;Russia 2018&quot;        &#x2F;&#x2F; 获取foo.baz属性, 如果不存在就创建这个属性        lang.getObject(&quot;obj.baz&quot;, true); &#x2F;&#x2F; 返回一个空的对象baz至路径obj中         lang.getObject(&quot;obj.baz.baz.baz.baz.baz&quot;, true); &#x2F;&#x2F; 每一个不存在的baz都相应的被创建，并且返回至obj。         console.log(obj);        &#x2F;*            obj = {                bar: &quot;Russia 2018&quot;,                buz: {                    buz: {                        buz: {                            buz: {                                buz: {                                }                            }                        }                    }                }            }        *&#x2F;        &#x2F;&#x2F; 定义一个非全局变量        var _obj = {            bar: &quot;Russia 2018&quot;        };        &#x2F;&#x2F; 指定从foo对象中获取bar        console.log(lang.getObject(&quot;bar&quot;, false, _obj)); &#x2F;&#x2F; returns &quot;Russia 2018&quot;        &#x2F;*            hitch(scope,method) 返回一个只在给定作用域内执行的函数。                @param: scope                         类型: Object                        描述: method执行时的作用域，如果method是字符串类型，则scope是包含method的对象。                                如果该参数为null时，则指向全局对象                @param: method                         类型: Function | String...                             描述: 要被挂载到scope内的函数function(){}，或者被挂载到scope内的method的名称。        *&#x2F;        console.log(&#39;------------------------- lang.hitch -----------------------------&#39;)        &#x2F;&#x2F;定义一个对象student        var Student = {            college: &quot;MIT&quot;,            getCollege: function () {                &#x2F;&#x2F;我们希望它能返回Student对象的college属性，即希望this指向Student本身                return this.college;            }        }        function printCollege(foo) {            console.log(&quot;College: &quot; + foo());        }        &#x2F;&#x2F; 函数上下文中this的值是函数调用者提供并且由当前调用表达式的形式而定的。         printCollege(Student.getCollege); &#x2F;&#x2F; &quot;College: undefined&quot;, 即 this 的值为 GLOBAL        &#x2F;&#x2F; 使用lang.hitch改变指向        printCollege(dojo.hitch(Student, Student.getCollege));&#x2F;&#x2F;&quot;College: MIT&quot;        printCollege(dojo.hitch(Student, &quot;getCollege&quot;));&#x2F;&#x2F;&quot;College: MIT&quot;        &#x2F;&#x2F;源码        dojo._hitchArgs = function (scope, method &#x2F;*,...*&#x2F;) {            &#x2F;&#x2F;排除第一个和第二个参数后转成一个数组，其实就是将method后面的参数作为目标函数的参数，转成一个数组            var pre = dojo._toArray(arguments, 2);            &#x2F;&#x2F;method是否是字符串类型            var named = dojo.isString(method);            &#x2F;&#x2F;返回一个新函数            return function () {                &#x2F;&#x2F;将这个新函数的的arguments转成数组，注意上下这两个arguments对象是不同的，上一个是属于dojo_hitchArgs函数，下一个是属性于返回的新函数的                var args = dojo._toArray(arguments);                &#x2F;&#x2F;取出目标函数，如果scope不存在，则函数为window[method]                var f = named ? (scope || dojo.global)[method] : method;                &#x2F;&#x2F;将两个参数数组进行连接，形成完整参数数组，这就是为什么通过hitch函数，参数可以分两次传递的原因                &#x2F;&#x2F;这个新函数的返回值就是目标函数执行的返回值，只是this变量进行了替换                return f &amp;&amp; f.apply(scope || this, pre.concat(args)); &#x2F;&#x2F; mixed            }; &#x2F;&#x2F; Function        };        hitch = function (&#x2F;*Object*&#x2F;scope, &#x2F;*Function|String*&#x2F;method &#x2F;*,...*&#x2F;) {            &#x2F;&#x2F;scope就是用于替换this变量的对象；method可以是一个字符串，或者是一个函数，用于指明替换哪个函数的this变量            if (arguments.length &gt; 2) {                &#x2F;&#x2F;如果参数个数多于两个则，调用dojo._hitchArgs函数                return dojo._hitchArgs.apply(dojo, arguments); &#x2F;&#x2F; Function            }            &#x2F;&#x2F;如果method未指定            if (!method) {                method = scope;                scope = null;            }            &#x2F;&#x2F;如果method是字符串类型            if (dojo.isString(method)) {                &#x2F;&#x2F;如果scope不存在则，scope为全局对象，即window                scope = scope || d.global;                if (!scope[method]) { throw ([&#39;dojo.hitch: scope[&quot;&#39;, method, &#39;&quot;] is null (scope=&quot;&#39;, scope, &#39;&quot;)&#39;].join(&#39;&#39;)); }                &#x2F;&#x2F;返回一个新函数，该函数调用scope[method]函数，并使this指向scope                return function () { return scope[method].apply(scope, arguments || []); }; &#x2F;&#x2F; Function            }            &#x2F;&#x2F;如果scope不存在，则直接返回该函数，这时并没有修改this变量            &#x2F;&#x2F;如果scope存在，则直接调用该函数，并使this指向scope            return !scope ? method : function () { return method.apply(scope, arguments || []); }; &#x2F;&#x2F; Function        };        &#x2F;*        mixin(dest,sources) 从sources对象复制&#x2F;添加它的所有属性、方法至dest对象，但不包括        在Object.prototype中发现的任何非标准扩展。如果某个属性指向对象，mixin只做浅拷贝。            @param: dest                     类型: Object                    描述: 复制&#x2F;添加的目标对象            @param: sources                     类型: Object                         描述: 被复制的源对象。        *&#x2F;        &#x2F;&#x2F; 针对mixin浅拷贝的情况设计一个简单实验        &#x2F;&#x2F;引入lang工具        console.log(&#39;--------------------------lang.mixin------------------------------&#39;)        &#x2F;&#x2F; 定义一个被指向的对象        var lastName = {            lastName: &quot;小龙&quot;        };        &#x2F;&#x2F; 定义一个主要对象        var Obj1 = {            &#x2F;&#x2F;这个属性直接赋值            firstName: &quot;李&quot;,            &#x2F;&#x2F;这个属性指向一个对象            lastName: lastName        }        &#x2F;&#x2F;使用mixin复制Obj1给Obj2        var Obj2 = lang.mixin({            firstName: &quot;哈？&quot;        }, Obj1);        &#x2F;&#x2F;查看Obj2的打印情况，输出&quot;李小龙&quot;，目标对象的firstName属性被覆盖        console.log(Obj2.firstName + Obj2.lastName.lastName);        &#x2F;&#x2F;查看Obj1的打印情况，输出&quot;李小龙&quot;        console.log(Obj1.firstName + Obj1.lastName.lastName);        &#x2F;&#x2F;修改Obj2        Obj2.firstName = &quot;张&quot;;        Obj2.lastName.lastName = &quot;学友&quot;;        &#x2F;&#x2F;查看Obj2的打印情况，输出&quot;张学友&quot;        console.log(Obj2.firstName + Obj2.lastName.lastName);        &#x2F;&#x2F;查看Obj1的打印情况，输出&quot;李学友&quot;??名字在Obj2修改的时候，Obj1的也跟着变化，因为指向的都是同一个值。这就是引用的特性        console.log(Obj1.firstName + Obj1.lastName.lastName);        &#x2F;&#x2F;例子二        declare(&quot;acme.Base&quot;, null, {            constructor: function (properties) {                &#x2F;&#x2F; property configuration:                lang.mixin(this, properties);                &#x2F;&#x2F;  ...            },            quip: &quot;I wasn&#39;t born yesterday, you know - I&#39;ve seen movies.&quot;,            &#x2F;&#x2F; ...        });        &#x2F;&#x2F; create an instance of the class and configure it        var b = new acme.Base({ quip: &quot;That&#39;s what it does!&quot; });        console.log(b.quip);        &#x2F;&#x2F;源码        mixin = function (&#x2F;*Object*&#x2F;obj, &#x2F;*Object...*&#x2F;props) {            if (!obj) { obj = {}; }&#x2F;&#x2F;如果obj目标对象不存在，则赋予一个空对象，防止异常            for (var i = 1, l = arguments.length; i &lt; l; i++) {&#x2F;&#x2F;遍历混入源对象，注意索引从1开始，因为需要排除obj目标对象                d._mixin(obj, arguments[i]);&#x2F;&#x2F;调用真正实现混入的_mixin函数            }            &#x2F;&#x2F;返回原来的目标对象            return obj; &#x2F;&#x2F; Object        }        var extraNames, extraLen, empty = {};        &#x2F;&#x2F;如果toString(覆盖从Object继承的toString)不能在for..in循环中遍历到，则extraNames为undefined，如果能则赋值为空列表        for (var i in { toString: 1 }) { extraNames = []; break; }        &#x2F;&#x2F;如果extraNames存在则dojo._extraNames会等于extraNames，即是一个空列表        &#x2F;&#x2F;如果extraNames为undefined，则dojo._extraNames为[&quot;hasOwnProperty&quot;, &quot;valueOf&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;toLocaleString&quot;, &quot;toString&quot;, &quot;constructor&quot;]        dojo._extraNames = extraNames = extraNames || [&quot;hasOwnProperty&quot;, &quot;valueOf&quot;, &quot;isPrototypeOf&quot;,            &quot;propertyIsEnumerable&quot;, &quot;toLocaleString&quot;, &quot;toString&quot;, &quot;constructor&quot;];        extraLen = extraNames.length;&#x2F;&#x2F;获取长度        dojo._mixin = function (&#x2F;*Object*&#x2F; target, &#x2F;*Object*&#x2F; source) {            var name, s, i;            &#x2F;&#x2F;遍历源对象中的属性            for (name in source) {                &#x2F;&#x2F;在混入的时候需要排除从Object继承而来的属性，除非源对象重新定义了从Object继承而来的属性                s = source[name];&#x2F;&#x2F;取出属性值                &#x2F;&#x2F;成立条件有：                &#x2F;&#x2F;1. 目标对象中不存在源对象中的某个属性                &#x2F;&#x2F;2. 目标对象与源对象属性值不相等并且 (该属性不是从Object继承而来或者源对象重新定义了从Object继承而来的属性)                if (!(name in target) || (target[name] !== s &amp;&amp; (!(name in empty) || empty[name] !== s))) {                    &#x2F;&#x2F;将源对象属性值赋给目标对象                    target[name] = s;                }            }            &#x2F;&#x2F; IE doesn&#39;t recognize some custom functions in for..in有些版本的IE对于重新定义从Object继承来而的属性不能识别，所以需要重新判断一次            if (extraLen &amp;&amp; source) {                for (i = 0; i &lt; extraLen; ++i) {                    name = extraNames[i];                    s = source[name];                    if (!(name in target) || (target[name] !== s &amp;&amp; (!(name in empty) || empty[name] !== s))) {                        target[name] = s;                    }                }            }            &#x2F;&#x2F;返回目标对象            return target; &#x2F;&#x2F; Object        }        &#x2F;*            partial(method) 与hitch类似，相当于把hitch()第一个参数置为null，基于hitch实现                @param: method                         类型: Function | String                        描述: 被绑定到某个作用域的方法。        *&#x2F;        console.log(&#39;--------------------------lang.partial------------------------------&#39;)        &#x2F;&#x2F; 实例        console.log(&quot;请在左侧点击按钮查看效果&quot;)        var myClick = function (presetValue, event) {            dojo.place(&quot;&lt;p&gt;&quot; + presetValue + &quot;&lt;&#x2F;p&gt;&quot;, &quot;appendLocation&quot;);        };        dojo.connect(dom.byId(&quot;myButton&quot;), &quot;click&quot;, lang.partial(myClick, &quot;This is preset text!&quot;));        &#x2F;&#x2F; 源码        partial = function (&#x2F;*Function|String*&#x2F;method &#x2F;*, ...*&#x2F;) {            var arr = [null];            &#x2F;&#x2F;将scope置为null            return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); &#x2F;&#x2F; Function        };        &#x2F;*            replace(tmpl,map,pattern) 轻量级的字符串替换、连接的工具函数。                @param: tmpl                         类型: String                        描述: 要进行替换部分内容的字符串模板。                @param: map                         类型: Object | Function                        描述: 提供替换内容的JSON对象。                @param: pattern                         类型: RegEx                    描述: 可选。用于规定什么样的内容将会被替换的正则表达式模板。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.replace------------------------------&#39;)        var output = dojo.replace(            &#x2F;&#x2F; 被处理的字符串模板            &quot;Hello, {name.first} {name.last} AKA {nick}!&quot;,            &#x2F;&#x2F; 替换内容            {                name: {                    first: &quot;Robert&quot;,                    middle: &quot;X&quot;,                    last: &quot;Cringely&quot;                },                nick: &quot;Bob&quot;            }        );        console.log(output);        &#x2F;*            setObject(name,value,context) 根据点分隔字符串路径（如A.B.C）设置对象属性                @param: name                         类型: String                        描述: &#39;A.B.C&#39;形式的对象路径。                @param: value                         类型: anything                        描述: 设置的内容。                @param: context                         类型: Object                        描述: 可选。指定name的根路径，默认GLOBAL。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.setObject------------------------------&#39;)        var family = {            father: &quot;父亲&quot;,            mother: &quot;母亲&quot;        }        &#x2F;&#x2F;指定在family内添加一个children:&quot;children&quot;        lang.setObject(&quot;children&quot;, &quot;孩子&quot;, family);        console.log(family);        &#x2F;&#x2F;缺点，会插到对象子属性的最前面        &#x2F;*              trim(str) 用于移除给定字符串参数的前后空格。                @param: str                         类型: String                        描述: 目标字符串。        *&#x2F;        &#x2F;&#x2F;实例        console.log(&#39;--------------------------lang.trim------------------------------&#39;)        var word = &quot;   What&#39;s your name? Thor  &quot;;        console.log(&quot;|&quot; + word + &quot;|&quot;);        console.log(&quot;|&quot; + lang.trim(word) + &quot;|&quot;);        &#x2F;&#x2F;不能去除字符串内空格\        &#x2F;&#x2F;isAlien()         console.log(&#39;--------------------------lang.isAlien----------------------------&#39;)        console.log(lang.isAlien(Function));    })    &#x2F;&#x2F; isArray(it) 如果时一个数组则返回真。    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isArrayLike(it) 类似于isArray()但是更加宽容，不严格要求测试对象是不是数组，而是根据对象是否具有    &#x2F;&#x2F; length属性进行判断，例如参数对象和DOM对象，使用isArrayLike()判断会返回true，而使用isArray()则返回false。    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isFunction(it) 如果时函数则返回true    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isObject(it) 如果时Javascript对象则返回ture（包括数组、函数或者Null）    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。    &#x2F;&#x2F; isString(it) 如果是字符串则返回true    &#x2F;&#x2F; @param: it     &#x2F;&#x2F;         类型: anything        &#x2F;&#x2F;         描述: 测试项。</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
            <tag> lang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dojo学习笔记--事件绑定on()</title>
      <link href="/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Aon/"/>
      <url>/2018/07/29/dojo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9Aon/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;on() 方法在元素上绑定事件，需要引用包dojo/on，通过on方法实现。<a id="more"></a><br>&emsp;&emsp;on方法不需要前缀。包括三个参数。<br>第一个：需要绑定events的元素<br>第二个：event名称<br>第三个：处理event的方法体，这个方法体有只一个参数，为event的对象，包括一些属性和方法，如果需要传递其他参数，将在后面讲到。<br>方法on的返回值是一个简单的对象，只有一个remove方法，执行这个方法，元素就会移除这个event。<br>还有一个方法on.once(element,event name,handler)，参数同on一样，这个方法顾名思义就是只执行一次，在执行了handler后将会自动remove。<br>一个元素可以绑定多个events，每个event按照绑定的先后顺序来执行的。<br><pre><code>require([&quot;dojo&#x2F;on&quot;, &quot;dojo&#x2F;dom&quot;, &quot;dojo&#x2F;dom-style&quot;, &quot;dojo&#x2F;mouse&quot;, &quot;dojo&#x2F;domReady!&quot;],function (on, dom, domStyle, mouse) {    var myButton = dom.byId(&quot;myButton&quot;),        myDiv = dom.byId(&quot;myDiv&quot;);    on(myButton, &quot;click&quot;, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;blue&quot;);    });    on(myDiv, mouse.enter, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;red&quot;);    });    var handler = on(myDiv, mouse.leave, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;&quot;);    });    handler.remove();&#x2F;&#x2F;移除event    on.once(myDiv, mouse.leave, function (evt) {        domStyle.set(myDiv, &quot;backgroundColor&quot;, &quot;&quot;);    });});</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dojo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决windows下命令执行出错:无法将&#39;hexo&#39;项识别为 cmdlet、函数、脚本文件或可运行程序的名称。</title>
      <link href="/2018/07/07/%E8%A7%A3%E5%86%B3windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BA%E9%94%99-%E6%97%A0%E6%B3%95%E5%B0%86-hexo-%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82/"/>
      <url>/2018/07/07/%E8%A7%A3%E5%86%B3windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BA%E9%94%99-%E6%97%A0%E6%B3%95%E5%B0%86-hexo-%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>hexo : 无法将“hexo”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。<a id="more"></a><br>所在位置 行:1 字符: 1<br>+ hexo<br>+ ~~~~<br>    + CategoryInfo          : ObjectNotFound: (hexo:String) [], CommandNotFoundException<br>    + FullyQualifiedErrorId : CommandNotFoundException<br>今天笔者换新电脑后进行资料迁移以及重新配置一遍工作环境，在迁移完这个博客的工程后，在工程中使用hexo new “name”创建新博客时一直报错，系统找不到指定的命令”hexo”，一般情况下出现这种错误有两种错误，一种是没有进行全局安装，另一种是全局安装目录没有加入系统环境变量PATH中。楼主先是测试第一中情况，执行<br><pre><code>npm install -g hexo-cli</code></pre><br>进行全局安装，再次运行hexo new “name”命令，依然报错，执行npm list –depth=0 -global查看当前已经进行全局安装的模块。<br><pre><code>-- hexo-cli@1.1.0</code></pre><br>可见hexo-cli是存在有的，那么我们看看第二种情况。查案看当前的PATH环境变量<br></p><p><div align="center"><img src="../../../../img/7/7/path.png" width="50%" height="50%"></div> <br><br>注意PATH中的第二行，这个其实就是npm的全局安装目录，全局变量模块都存于此目录（C:\Users\用户名\AppData\Roaming\npm）下，所以需要在PATH环境变量中加入此目录路径，那么为什么还会报错呢？其实这里用户名是不存在的，昨天笔者拿到新本子开机心切，随便起了个1111的用户名，后来还是觉得太随便太丑了，就强行改了回来，结果在改名之前就已经安装了编辑器并且安装了node，应该就是当时node配置环境变量时使用了当时的1111用户名，所以才会出项这种情况。所以该回来之后，再执行hexo new “name”</p><p><div align="center"><img src="../../../../img/7/7/result.png" width="80%" height="80%"></div> <br><br>OK，大功告成。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS实战笔记--实现tree组件</title>
      <link href="/2018/07/01/JS%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%AE%9E%E7%8E%B0tree%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/07/01/JS%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-%E5%AE%9E%E7%8E%B0tree%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;前些天去面试，被要求用原生JS实现一个能遍历数组生成树状展开列表(其实不知道是不是这样表述)的tree组件，花了我不少的时间和精力，看来自己的实战能力确实是不够，不过后来还是做出来了<a id="more"></a>，效果不敢说如何，直接上图<br>&gt;<img src="../../../../img/7/1/效果.JPG" alt="avatar"><br>&gt;<br>  &emsp;&emsp;这个组件的开发环境为windows10 + webStorm2017 + chrome67 + webpack + babel，使用ES6和原生JS开发，未做浏览器兼容。能够实现遍历多重数组并把数组的title属性转换为li标签的内容文本，把数组的id属性转换为li标签的id属性，具有展开和折叠的动画效果，鼠标移入移出时背景色改变的动画效果，以及双击列表打印当前列表信息{title:”….”,id:”…”}等。这里直接上组件的代码，代码中已有完整注释，组件中使用得比较多的技巧有递归遍历、事件代理、三元运算，<a href="https://github.com/1206497655/tree" target="_blank" rel="noopener">点击这里</a>查看完整项目。<br><pre><code>function Tree(obj) {    const valueArr = Object.values(obj);    this.baseNode = valueArr[0];    this.treeData = valueArr[1];    this.dblclick = valueArr[2];}&#x2F;******************************** 递归遍历数组生成树状列表方法 *********************************&#x2F;Tree.prototype.initArrayTree = function(data){        let tree = &#39;&lt;ul class=&quot;ulTree&quot; id=&quot;tree-container&quot;&gt;&#39;;            for (const i in data) {                if(data.hasOwnProperty(i)){                    tree += `&lt;li id=${data[i].id} class=&quot;liTree&quot; &gt;${data[i].title}`;                    if (data[i].children) {                        tree += this.initArrayTree(data[i].children);                    }                    tree += `&lt;&#x2F;li&gt;`;                }            }        tree += &#39;&lt;&#x2F;ul&gt;&#39;;        return tree};&#x2F;********************************** * 递归获取数组内元素的总长度方法 * **********************************&#x2F;Tree.prototype.getArrayLength = function (data){    let arrLength = data.length;    for (const i in data) {        if(data.hasOwnProperty(i)){            if (data[i].children) {                arrLength += this.getArrayLength(data[i].children);            }        }    }    return arrLength};&#x2F;************************************************************* * 递归获取元素的所有后代元素，转换为普通数组，此方法暂未用到* *************************************************************&#x2F;Tree.prototype.getChildNode = function(node){    &#x2F;** 先找到子结点 **&#x2F;    let allLiNodes = [];    let nodeList = node.childNodes;    &#x2F;** 把NodeList对象转换为Array对象 **&#x2F;    for(let i=0, len = nodeList.length; i &lt; len; i++){        allLiNodes.push(nodeList[i]);    }    for(let i = 0;i &lt; nodeList.length;i++){        &#x2F;**************************************************************************         * childNode获取到到的节点包含了各种类型的节点                            *         * 但是我们只需要元素节点  通过nodeType去判断当前的这个节点是不是元素节点 *         * ************************************************************************&#x2F;        if(nodeList[i].nodeType === 1){            allLiNodes = allLiNodes.concat(this.getChildNode(nodeList[i]));        }    }    return allLiNodes;};&#x2F;************************** * 可操作树状列表生成方法 * **************************&#x2F;Tree.prototype.createTree = function () {    const data = this.treeData;    const node = this.baseNode;    const click = this.dblclick;    &#x2F;** 消除单击双击冲突用到的定时器 **&#x2F;    let TimeFn = null;    &#x2F;** 获取数组元素总个数，设置maxHeight值时会用到 **&#x2F;    const dataLength = this.getArrayLength(data);    &#x2F;** 获取树状列表 **&#x2F;    const treeBody=  this.initArrayTree(data);    &#x2F;** 使用DIV包裹起来 **&#x2F;    node.innerHTML = `&lt;div style=&quot;width: 180px; border: 1px solid black; height: auto&quot;&gt;${treeBody}&lt;&#x2F;div&gt;`;    &#x2F;** 通过class类添加通用样式样式 **&#x2F;    document.styleSheets[0].addRule(&#39;.ulTree&#39;, &#39;background-color: white;margin: 0;&#39;);    document.styleSheets[0].addRule(&#39;.liTree&#39;, &#39;list-style-type: none;height:30px;line-height:30px;transition: all .3s ease 0s;&#39;);    document.styleSheets[0].addRule(&#39;.arrow&#39;, &#39;border:5px solid transparent; border-left:5px solid #000;margin-left:10px;overflow:hidden;height:0;width:0;display:inline-block;&#39;);    document.styleSheets[0].addRule(&#39;.arrow-expend&#39;, &#39;border:5px solid transparent; border-top:5px solid #000;margin-left:10px;overflow:hidden;height:0;width:0;display:inline-block;&#39;);    &#x2F;** 循环添加组件中ul的样式 **&#x2F;    const ul = document.getElementsByClassName(&#39;ulTree&#39;);    for (let i=0;i&lt;ul.length;i++){        ul[i].style.cssText = i &gt; 0 ? &#39;padding-left: 20px;&#39;: &#39;&#39;    }    &#x2F;** 箭头图标 **&#x2F;    const arrow = &#39;&lt;span class=&quot;arrow&quot;&gt;&lt;&#x2F;span&gt;&#39;;    &#x2F;** 循环添加组件中li标签的样式 **&#x2F;    const li = document.getElementsByClassName(&#39;liTree&#39;);    &#x2F;** 无法通过getElementsByClassName获得的对象动态修改className **&#x2F;    &#x2F;** 决定列表是否应该隐藏，当列表的父元素的父元素为最外层的DIV时不隐藏 **&#x2F;    for(let i=0; i&lt;li.length; i++){        li[i].style.cssText = li[i].parentNode.parentNode.nodeName === &#39;DIV&#39;? &#39;&#39; : &#39;max-height:0;overflow:hidden&#39;;        console.log(li[i].className);        &#x2F;** 当列表元素可展开时添加箭头图标 **&#x2F;        li[i].childNodes.length &gt; 1 ?            li[i].innerHTML = arrow + li[i].innerHTML:            li[i].style.textIndent = &#39;20px&#39;;    }    &#x2F;*********************************************     *  监听li元素绑定鼠标移入事件，改变背景颜色 *     *********************************************&#x2F;    node.addEventListener(&#39;mouseover&#39;,function (e) {        const target=e.target;        if(target.nodeName === &quot;LI&quot;){            e.target.style.backgroundColor = &#39;#4D7FFF&#39;;        }    });    &#x2F;********************************************     * 监听li元素绑定鼠标移出事件，改变背景颜色 *     ********************************************&#x2F;    node.addEventListener(&#39;mouseout&#39;,function (e) {        const target=e.target;        if(target.nodeName === &quot;LI&quot;){            e.target.style.backgroundColor = &#39;#ffffff&#39;;        }    });    &#x2F;*****************************     *  处理树状列表的展开与隐藏 *     *****************************&#x2F;    node.addEventListener(&#39;click&#39;, function (e) {        &#x2F;** 每次点击清理定时器，消除与双击的冲突 **&#x2F;        clearTimeout(TimeFn);        &#x2F;** 200ms内鼠标不点击第二次时执行function **&#x2F;        TimeFn = setTimeout(function(){            const target = e.target;            &#x2F;** 保证仅点击的元素为li时才生效操作 **&#x2F;            if(target.nodeName === &#39;LI&#39;){                &#x2F;** 保证仅点击的元素含有span子元素时才生效操作，改变箭头图标 **&#x2F;                if(target.childNodes[0].nodeName === &#39;SPAN&#39;){                    const _temp = target.childNodes[0];                    _temp.className = _temp.className === &#39;arrow&#39; ? &#39;arrow-expend&#39; : &#39;arrow&#39;;                }                &#x2F;*****************************************************************************                 * 列表的隐藏与展开以及动画，展开&#x2F;隐藏动画的原理是通过css过渡transition实现的，  *                 * 动态设定元素的maxHeight时实现过渡效果，当使用height:auto或max_height:auto *                 *  将无法实现动画，因为浏览器无法从auto值进行过渡                           *                 *****************************************************************************&#x2F;                &#x2F;** 不含有子元素时，不进行操作 **&#x2F;                if (target.children.length === 0) {                    return false                } else {                    const temp_node = target.childNodes[2];                    target.style.height = &#39;auto&#39;;                    for (let i = 0; i&lt;temp_node.childNodes.length;i++){                        const temp_style = temp_node.childNodes[i].style;                        temp_style.maxHeight =                            temp_style.maxHeight === &#39;0px&#39; ?                                `${30*(temp_node.childNodes.length + dataLength)}px`:                                &#39;0px&#39;;                    }                }            }        },200);    });    &#x2F;****************************     * 双击打印当前元素内容和id *     ****************************&#x2F;    node.addEventListener(&#39;dblclick&#39;,function (e) {        clearTimeout(TimeFn);        const target = e.target;        &#x2F;** 保证仅点击的元素为li时才生效操作 **&#x2F;        if(target.nodeName === &#39;LI&#39;){            &#x2F;** 打印点击元素的内容和ID。当前元素存在两种情况，有span节点和无span节点，             * 有span节点时文本节点位于当前元素子节点的第二位，无span节点时则位于第一位 **&#x2F;            const data =  target.childNodes[0].nodeName === &#39;SPAN&#39; ?                `{title:${target.childNodes[1].textContent},id:${target.id}}`:                `{title:${target.childNodes[0].textContent},id:${target.id}}`;            click(&#39;dblclick&#39;, data);        }    });};export default Tree</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS学习笔记--原型和原型继承</title>
      <link href="/2018/06/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;相信许多人和我一样弄不清楚原型的概念，原型究竟是个什么东西？现在结合笔者所学的知识以及笔记，谈谈笔者对原型的理解。<a id="more"></a><br><br> &emsp;&emsp;在js中原型主要分为prototype(显式原型)、_proto_(隐式原型)。_proto_是每一个对象都具有的属性，而prototype是函数对象Function才具有的属性。他们之间具有一个直接的指向关系：_proto_指向构造函数的prototype，意思就是构造函数Function.prototype的所有属性和方法都可以让_proto_\查询和使用。当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_(即它的构造函数的Function.prototype中寻找)。<br><br> &emsp;&emsp;下面举个例子</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//构造函数</span><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//给Foo函数的原型添加一个alerName方法</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>alertName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建示例</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span>printName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//测试</span>f<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">alertName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>&emsp;&emsp;在上述例子中，printName方法属于f对象本身的方法而不是构造函数Foo的方法，所以调用f.printName方法时，控制台输出</p><p><div align="center"><img src="/img/6/12/consoleLog.JPG"></div> <br><br>但是当调用f.alertName方法时，浏览器同样弹出了警告框</p><p><div align="center"><img src="/img/6/12/alert.JPG"></div> <br><br>这是为什么呢？这就是笔者所说的，_proto_指向问题，当调用对象自身没有的属性和方法时，js解释器会根据当前对象的_proto_指向的构造函数Foo.prototype中去寻找有无该属性或方法，如果有便返回执行，如果没有便报undefined错误。而这个其实就是我们常说的原型继承。<br>&emsp;&emsp;有趣的是，Foo.prototype其实也是一个普通对象(js万物皆对象)，那么它必然也存在有_proto_和prototype以及它们之间的指向问题，Foo.prototype_proto_究竟指向谁？这个问题留给大家思考。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的个人博客- -诞生</title>
      <link href="/2018/06/10/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%AF%9E%E7%94%9F/"/>
      <url>/2018/06/10/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%AF%9E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;嗨！大家好，和大家打个招呼！我是Leno，我是一名普通本科毕业生，写这篇博客为止我还没有工作，希望从事web前端开发。<a id="more"></a>这个博客是借助GitHug + Hexo实现的静态博客。网上有非常棒的教程<a href="https://www.jianshu.com/p/863f3f2d1733" target="_blank" rel="noopener">点击这里</a>，不记得从什么时候开始笔者就希望能拥有一个属于自己开发的博客，虽然现在还不够能力完全由自己开发，只能借助第三方方案实现，但是我相信以后总会有的。<br><br>&emsp;&emsp;笔者希望使用这个博客来分享一些在我的学习和工作的经验，或者是生活中遇到的烦恼，或者一些开心的事情，希望能记录自己点滴的同时也给大家带来一点小小的帮助。博客不定时更新，请大家多多关照(:</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
